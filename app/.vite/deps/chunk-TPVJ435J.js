import {
  E2 as E3,
  F as F2,
  P as P3,
  Q as Q3,
  R as R4,
  a as a7,
  c as c7,
  e2 as e7,
  e3 as e8,
  h as h5,
  k as k4,
  p as p2,
  t as t4,
  t2 as t5,
  u as u7,
  w as w4,
  y as y3
} from "./chunk-YPP5HIGV.js";
import {
  J2 as J,
  O as O2,
  R as R3,
  R2 as R5,
  V as V3,
  c as c5,
  j as j9,
  m as m3,
  r as r6,
  w as w3
} from "./chunk-X6OZYL6W.js";
import {
  c as c6,
  l2 as l5
} from "./chunk-FIOJSKII.js";
import {
  M as M3,
  R as R2,
  T,
  j as j8,
  x as x3
} from "./chunk-JUMO2VIG.js";
import {
  t as t3
} from "./chunk-2UBP7L6V.js";
import {
  Et,
  Le,
  N as N3,
  Ut,
  Zt,
  ge,
  gt,
  qt,
  yt
} from "./chunk-FAAI5VMG.js";
import {
  E as E2,
  c as c4,
  h as h4
} from "./chunk-6MN3R543.js";
import {
  N as N2,
  j as j7
} from "./chunk-NJTJZUTI.js";
import {
  t as t2
} from "./chunk-3PS636OJ.js";
import {
  a as a6,
  d as d4,
  f as f3,
  h as h3,
  j as j6,
  o as o4
} from "./chunk-DMO5AKFB.js";
import {
  k as k3,
  x as x2
} from "./chunk-SOIGHC7A.js";
import {
  a as a5,
  i as i3
} from "./chunk-5BFUNAMR.js";
import {
  h
} from "./chunk-KT6X6Y6M.js";
import {
  l as l4,
  y as y2
} from "./chunk-S4ARCHTK.js";
import {
  K,
  W
} from "./chunk-QUTHUJLU.js";
import {
  n as n3
} from "./chunk-GTKHPYCP.js";
import {
  e as e5
} from "./chunk-NQPBPVRE.js";
import {
  E,
  a as a4,
  b as b2,
  j as j5,
  m as m2,
  p,
  u as u5
} from "./chunk-PFFYYIYN.js";
import {
  t
} from "./chunk-NVEHOQKI.js";
import {
  c as c3
} from "./chunk-YINRFSE5.js";
import {
  L as L2,
  R
} from "./chunk-HONYA6AI.js";
import {
  e as e3
} from "./chunk-NOMJWA3C.js";
import {
  o as o5
} from "./chunk-HRBSIPTV.js";
import {
  e as e6,
  r as r5
} from "./chunk-JPJMYA5I.js";
import {
  u as u6
} from "./chunk-CTBXY22F.js";
import {
  h as h2
} from "./chunk-PV4EUSKO.js";
import {
  F,
  g as g4
} from "./chunk-DH57DJ4C.js";
import {
  l as l3
} from "./chunk-U7ERRXB6.js";
import {
  M as M2,
  e as e4,
  f as f2,
  j as j4,
  k as k2,
  l as l2,
  o as o3,
  u as u4
} from "./chunk-K35H6D4D.js";
import {
  A as A2,
  I,
  P as P2,
  Q as Q2,
  _ as _2,
  c as c2,
  g as g3,
  o as o2,
  s as s3,
  u as u3,
  w as w2
} from "./chunk-UMYFDXOJ.js";
import {
  y
} from "./chunk-PXJIE4N5.js";
import {
  b
} from "./chunk-5X74MKXM.js";
import {
  O
} from "./chunk-4WERUJEK.js";
import {
  u as u2
} from "./chunk-WLGGSXQY.js";
import {
  j as j3
} from "./chunk-T7KGE6VP.js";
import {
  M,
  a as a3,
  z
} from "./chunk-T57WVICI.js";
import {
  P
} from "./chunk-W633AKTD.js";
import {
  n
} from "./chunk-UCMTPLHQ.js";
import {
  c,
  f
} from "./chunk-JLFV7EBO.js";
import {
  _,
  n as n2,
  r as r4
} from "./chunk-JLFSX3JT.js";
import {
  S,
  j,
  j2
} from "./chunk-YUVX6H42.js";
import {
  g as g2
} from "./chunk-RDUV6YP6.js";
import {
  r as r2
} from "./chunk-6P7HXSJ6.js";
import {
  $,
  N,
  Q,
  V as V2,
  Y,
  ie,
  ne,
  r2 as r3,
  re,
  s3 as s2,
  x
} from "./chunk-LTDNORB5.js";
import {
  A,
  C,
  d as d3,
  w
} from "./chunk-YSPSOPLL.js";
import {
  V
} from "./chunk-AJSC5XSW.js";
import {
  i as i2
} from "./chunk-I4HN3ELT.js";
import {
  d as d2
} from "./chunk-ACGZOBZ6.js";
import {
  g,
  i2 as i,
  m
} from "./chunk-RYSF6YCR.js";
import {
  a3 as a2
} from "./chunk-4LTV6KQ5.js";
import {
  r
} from "./chunk-PPIAYGRE.js";
import {
  L,
  d,
  e,
  e2,
  k,
  l2 as l,
  o2 as o,
  u2 as u
} from "./chunk-M6FNW7GP.js";
import {
  a
} from "./chunk-CWMZW2S5.js";
import {
  G,
  s
} from "./chunk-2N2W26AY.js";

// node_modules/@arcgis/core/views/interactive/ManipulatorCollection.js
var a8;
!function(t9) {
  t9[t9.WhenToolEditable = 0] = "WhenToolEditable", t9[t9.WhenToolNotEditable = 1] = "WhenToolNotEditable", t9[t9.Always = 2] = "Always";
}(a8 || (a8 = {}));
var i4 = class {
  constructor() {
    this._isToolEditable = true, this._manipulators = new V(), this._resourceContexts = { manipulator3D: {} }, this._attached = false;
  }
  set isToolEditable(t9) {
    this._isToolEditable = t9;
  }
  get length() {
    return this._manipulators.length;
  }
  add(t9, i10 = a8.WhenToolEditable) {
    this.addMany([t9], i10);
  }
  addMany(t9, i10 = a8.WhenToolEditable) {
    for (const a11 of t9) {
      const t10 = { manipulator: a11, visibilityPredicate: i10, attached: false };
      this._manipulators.add(t10), this._attached && this._updateManipulatorAttachment(t10);
    }
  }
  remove(t9) {
    for (let a11 = 0; a11 < this._manipulators.length; a11++) if (this._manipulators.at(a11).manipulator === t9) {
      const t10 = this._manipulators.splice(a11, 1)[0];
      this._detachManipulator(t10);
      break;
    }
  }
  removeAll() {
    this._manipulators.forEach((t9) => {
      this._detachManipulator(t9);
    }), this._manipulators.removeAll();
  }
  attach() {
    this._manipulators.forEach((t9) => {
      this._updateManipulatorAttachment(t9);
    }), this._attached = true;
  }
  detach() {
    this._manipulators.forEach((t9) => {
      this._detachManipulator(t9);
    }), this._attached = false;
  }
  destroy() {
    this.detach(), this._manipulators.forEach(({ manipulator: t9 }) => t9.destroy()), this._manipulators.destroy(), this._resourceContexts = null;
  }
  on(t9, a11) {
    return this._manipulators.on(t9, (t10) => {
      a11(t10);
    });
  }
  forEach(t9) {
    for (const a11 of this._manipulators.items) t9(a11);
  }
  some(t9) {
    return this._manipulators.items.some(t9);
  }
  toArray() {
    const t9 = [];
    return this.forEach((a11) => t9.push(a11.manipulator)), t9;
  }
  intersect(t9, a11) {
    let i10 = null, e13 = Number.MAX_VALUE;
    return this._manipulators.forEach(({ manipulator: o7, attached: s4 }) => {
      if (!s4 || !o7.interactive) return;
      const r9 = o7.intersectionDistance(t9, a11);
      null != r9 && r9 < e13 && (e13 = r9, i10 = o7);
    }), i10;
  }
  _updateManipulatorAttachment(t9) {
    this._isManipulatorItemVisible(t9) ? this._attachManipulator(t9) : this._detachManipulator(t9);
  }
  _attachManipulator(t9) {
    t9.attached || (t9.manipulator.attach && t9.manipulator.attach(this._resourceContexts), t9.attached = true);
  }
  _detachManipulator(t9) {
    if (!t9.attached) return;
    const a11 = t9.manipulator;
    a11.grabbing = false, a11.dragging = false, a11.hovering = false, a11.selected = false, a11.detach && a11.detach(this._resourceContexts), t9.attached = false;
  }
  _isManipulatorItemVisible(t9) {
    return t9.visibilityPredicate === a8.Always || (this._isToolEditable ? t9.visibilityPredicate === a8.WhenToolEditable : t9.visibilityPredicate === a8.WhenToolNotEditable);
  }
};

// node_modules/@arcgis/core/views/interactive/InteractiveToolBase.js
var n4 = class extends g {
  constructor(t9) {
    super(t9), this.manipulators = new i4(), this.automaticManipulatorSelection = true, this.hasGrabbedManipulators = false, this.hasHoveredManipulators = false, this.firstGrabbedManipulator = null, this.created = false, this.removeIncompleteOnCancel = true, this._editableFlags = /* @__PURE__ */ new Map([[o5.MANAGER, true], [o5.USER, true]]), this._creationFinishedResolver = L();
  }
  get active() {
    return null != this.view && this.view.activeTool === this;
  }
  set visible(t9) {
    this._get("visible") !== t9 && (this._set("visible", t9), this._syncVisible());
  }
  get editable() {
    return this.getEditableFlag(o5.USER);
  }
  set editable(t9) {
    this.setEditableFlag(o5.USER, t9);
  }
  get updating() {
    return false;
  }
  get cursor() {
    return null;
  }
  get hasFocusedManipulators() {
    return this.hasGrabbedManipulators || this.hasHoveredManipulators;
  }
  destroy() {
    this.manipulators.destroy(), this._set("view", null);
  }
  onAdd() {
    this._syncVisible();
  }
  activate() {
    null != this.view && (this.view.focus(), this.onActivate());
  }
  deactivate() {
    this.onDeactivate();
  }
  handleInputEvent(t9) {
    this.onInputEvent(t9);
  }
  handleInputEventAfter(t9) {
    this.onInputEventAfter(t9);
  }
  setEditableFlag(t9, e13) {
    this._editableFlags.set(t9, e13), this.manipulators.isToolEditable = this.internallyEditable, this._updateManipulatorAttachment(), t9 === o5.USER && this.notifyChange("editable"), this.onEditableChange(), this.onManipulatorSelectionChanged();
  }
  getEditableFlag(t9) {
    return this._editableFlags.get(t9) ?? false;
  }
  endDrag() {
    const t9 = this.view.inputManager.latestPointerLocation;
    if (!t9) return;
    let e13 = false;
    this.manipulators.forEach(({ manipulator: i10 }) => {
      i10.dragging && (e13 = true, i10.events.emit("drag", { action: "end", start: t9, screenPoint: t9 }));
    }), e13 && (this.view.toolViewManager.activeTool = null);
  }
  whenCreated() {
    return this._creationFinishedResolver.promise;
  }
  onManipulatorSelectionChanged() {
  }
  onActivate() {
  }
  onDeactivate() {
  }
  onShow() {
  }
  onHide() {
  }
  onEditableChange() {
  }
  onInputEvent(t9) {
  }
  onInputEventAfter(t9) {
  }
  get internallyEditable() {
    return this.getEditableFlag(o5.USER) && this.getEditableFlag(o5.MANAGER);
  }
  finishToolCreation() {
    this.created || this._creationFinishedResolver.resolve(this), this._set("created", true);
  }
  _syncVisible() {
    if (this.initialized) {
      if (this.visible) this._show();
      else if (this._hide(), this.active) return void (this.view.activeTool = null);
    }
  }
  _show() {
    this._updateManipulatorAttachment(), this.onShow();
  }
  _hide() {
    this._updateManipulatorAttachment(), this.onHide();
  }
  _updateManipulatorAttachment() {
    this.visible ? this.manipulators.attach() : this.manipulators.detach();
  }
};
r([m({ constructOnly: true })], n4.prototype, "view", void 0), r([m({ readOnly: true })], n4.prototype, "active", null), r([m({ value: true })], n4.prototype, "visible", null), r([m({ value: true })], n4.prototype, "editable", null), r([m({ readOnly: true })], n4.prototype, "manipulators", void 0), r([m({ readOnly: true })], n4.prototype, "updating", null), r([m()], n4.prototype, "cursor", null), r([m({ readOnly: true })], n4.prototype, "automaticManipulatorSelection", void 0), r([m()], n4.prototype, "hasFocusedManipulators", null), r([m()], n4.prototype, "hasGrabbedManipulators", void 0), r([m()], n4.prototype, "hasHoveredManipulators", void 0), r([m()], n4.prototype, "firstGrabbedManipulator", void 0), r([m({ readOnly: true })], n4.prototype, "created", void 0), r([m({ readOnly: true })], n4.prototype, "removeIncompleteOnCancel", void 0), n4 = r([a2("esri.views.interactive.InteractiveToolBase")], n4);

// node_modules/@arcgis/core/undoredo/OperationStatus.js
var e9;
!function(e13) {
  e13[e13.NeverApplied = 0] = "NeverApplied", e13[e13.Applied = 1] = "Applied", e13[e13.Undone = 2] = "Undone";
}(e9 || (e9 = {}));

// node_modules/@arcgis/core/undoredo/UndoRedoError.js
var r7;
!function(r9) {
  r9.UndoRedoUpdating = "UndoRedoUpdating", r9.UndoInvalidError = "UndoInvalidError", r9.RedoInvalidError = "RedoInvalidError", r9.ApplyInvalidError = "ApplyInvalidError";
}(r7 || (r7 = {}));
var o6 = { [r7.UndoRedoUpdating]: "Cannot perform operation whilst undo redo is updating", [r7.UndoInvalidError]: "There are no items to Undo", [r7.RedoInvalidError]: "There are no items to Redo", [r7.ApplyInvalidError]: "Cannot apply an item that is already applied" };
var d5 = class extends Error {
  constructor() {
    super(o6[r7.UndoRedoUpdating]), this.type = "undo-redo-updating-error";
  }
};
var n5 = class extends Error {
  constructor() {
    super(o6[r7.UndoInvalidError]), this.type = "undo-redo-undo-error";
  }
};
var e10 = class extends Error {
  constructor() {
    super(o6[r7.RedoInvalidError]), this.type = "undo-redo-redo-error";
  }
};
var t6 = class extends Error {
  constructor() {
    super(o6[r7.ApplyInvalidError]), this.type = "undo-redo-apply-error";
  }
};

// node_modules/@arcgis/core/undoredo/UndoableOperation.js
var a9;
!function(t9) {
  t9[t9.Apply = 0] = "Apply", t9[t9.Undo = 1] = "Undo", t9[t9.Redo = 2] = "Redo";
}(a9 || (a9 = {}));
var n6 = class extends g {
  constructor() {
    super(...arguments), this.name = "", this.tag = Symbol(), this.status = e9.NeverApplied;
  }
  get canUndo() {
    return this.status === e9.Applied;
  }
  get canRedo() {
    return this.status === e9.Undone;
  }
  async executeUndoRedoOperation(t9) {
    switch (t9) {
      case a9.Apply:
        if (this.status !== e9.NeverApplied) throw new t6();
        return await this.apply(), void (this.status = e9.Applied);
      case a9.Undo:
        if (this.status !== e9.Applied) throw new n5();
        return await this.undo(), void (this.status = e9.Undone);
      case a9.Redo:
        if (this.status !== e9.Undone) throw new n5();
        return await this.redo(), void (this.status = e9.Applied);
    }
  }
};
r([m()], n6.prototype, "name", void 0), r([m()], n6.prototype, "tag", void 0), n6 = r([a2("esri.undoredo.UndoableOperation")], n6);

// node_modules/@arcgis/core/UndoRedo.js
var u8 = class extends g {
  constructor() {
    super(...arguments), this._stack = new V(), this._stackPosition = -1, this._updatingHandles = new h2();
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get canUndo() {
    return this.hasUndo && !this.updating;
  }
  get hasUndo() {
    return this._stackPosition >= 0;
  }
  get canRedo() {
    return this.hasRedo && !this.updating;
  }
  get hasRedo() {
    return this._stackPosition < this._stack.length - 1;
  }
  _truncateForwardStack() {
    this._stack.splice(this._stackPosition + 1, this._stack.length - this._stackPosition).forEach((t9) => t9.destroy());
  }
  _drainStack() {
    this._stack.drain((t9) => t9.destroy()), this._stackPosition = -1;
  }
  async undo() {
    if (!this.hasUndo) throw new n5();
    if (this.updating) throw new d5();
    const t9 = this._stack.getItemAt(this._stackPosition);
    t9 && await this._updatingHandles.addPromise((async () => {
      await t9.executeUndoRedoOperation(a9.Undo), --this._stackPosition, t9.canRedo || this._truncateForwardStack();
    })());
  }
  async redo() {
    if (!this.hasRedo) throw new e10();
    if (this.updating) throw new d5();
    const t9 = this._stack.getItemAt(this._stackPosition + 1);
    if (!t9) throw new e10();
    await this._updatingHandles.addPromise((async () => {
      await t9.executeUndoRedoOperation(a9.Redo), ++this._stackPosition;
    })());
  }
  peekUndo() {
    if (this.canUndo) return this._stack.getItemAt(this._stackPosition);
  }
  peekRedo() {
    if (this.canRedo) return this._stack.getItemAt(this._stackPosition + 1);
  }
  async inject(t9) {
    if (this.updating) throw new d5();
    await this._updatingHandles.addPromise((async () => {
      t9.status === e9.NeverApplied && await t9.executeUndoRedoOperation(a9.Apply), t9.canUndo ? (this._stack.splice(this._stackPosition + 1, 0, t9), this._stackPosition++) : this._stackPosition > -1 && (this._stack.splice(0, this._stackPosition + 1).forEach((t10) => t10.destroy()), this._stackPosition = -1);
    })());
  }
  async add(t9) {
    if (this.updating) throw new d5();
    await this._updatingHandles.addPromise((async () => {
      t9.status === e9.NeverApplied && await t9.executeUndoRedoOperation(a9.Apply), this._stackPosition >= -1 && this._truncateForwardStack(), t9.canUndo ? (this._stack.push(t9), this._stackPosition = this._stack.length - 1) : this._drainStack();
    })());
  }
  async removeTagged(t9, s4 = false) {
    if (this.updating && !s4) return;
    await w(() => !this.updating);
    const a11 = new V();
    for (let i10 = 0; i10 < this._stack.length; i10++) {
      const s5 = this._stack.getItemAt(i10);
      s5 && (s5.tag === t9 ? (s5.destroy(), i10 === this._stackPosition && (this._stackPosition = a11.length - 1)) : a11.push(s5));
    }
    this._stack = a11, this._stackPosition > a11.length - 1 && (this._stackPosition = a11.length - 1);
  }
  async clear(t9 = false) {
    if (this.updating && !t9) throw new d5();
    await w(() => !this.updating), this._drainStack();
  }
};
r([m()], u8.prototype, "_stack", void 0), r([m()], u8.prototype, "_stackPosition", void 0), r([m()], u8.prototype, "updating", null), r([m({ readOnly: true })], u8.prototype, "canUndo", null), r([m({ readOnly: true })], u8.prototype, "hasUndo", null), r([m({ readOnly: true })], u8.prototype, "canRedo", null), r([m({ readOnly: true })], u8.prototype, "hasRedo", null), u8 = r([a2("esri.UndoRedo")], u8);

// node_modules/@arcgis/core/views/draw/support/CreateOperationGeometry.js
var l6 = class {
  constructor() {
    this.committedVertices = null, this.cursorVertex = null, this.full = null, this.outline = null, this.cursorEdge = null, this.circle = null, this.rectangle = null;
  }
};

// node_modules/@arcgis/core/geometry/Circle.js
var f4;
var g5 = f4 = class extends j3 {
  constructor(e13) {
    super(e13), this.center = null, this.geodesic = false, this.numberOfPoints = 60, this.radius = 1e3, this.radiusUnit = "meters";
  }
  initialize() {
    const e13 = this.center, o7 = this.numberOfPoints;
    if (this.hasZ = (e13 == null ? void 0 : e13.hasZ) ?? false, 0 !== this.rings.length || !e13) return;
    const c12 = x(this.radius, this.radiusUnit, "meters"), n8 = e13.spatialReference;
    let p7, l9 = "geographic";
    if (n8.isWebMercator ? l9 = "webMercator" : (null != (n8.wkid && r3[n8.wkid]) || (n8.wkt2 || n8.wkt) && re(n8.wkt2 || n8.wkt)) && (l9 = "projected"), this.geodesic) {
      let r9;
      switch (l9) {
        case "webMercator":
          r9 = S(e13);
          break;
        case "projected":
          console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");
          break;
        case "geographic":
          r9 = e13;
      }
      p7 = this._createGeodesicCircle(r9, c12, o7), "webMercator" === l9 && (p7 = j(p7));
    } else {
      let r9;
      "webMercator" === l9 || "projected" === l9 ? r9 = c12 / V2(e13.spatialReference) : "geographic" === l9 && (r9 = Y(c12, "meters", s2(e13.spatialReference).radius)), p7 = this._createPlanarCircle(e13, r9, o7);
    }
    this.spatialReference = p7.spatialReference, this.addRing(p7.rings[0]);
  }
  clone() {
    const { center: e13, numberOfPoints: r9, radius: t9, radiusUnit: s4, geodesic: i10 } = this;
    return new f4({ center: e13 == null ? void 0 : e13.clone(), numberOfPoints: r9, radius: t9, radiusUnit: s4, geodesic: i10 });
  }
  _createGeodesicCircle(e13, r9, t9) {
    const s4 = [], i10 = [e13.x, e13.y];
    for (let o7 = 0; o7 < 360; o7 += 360 / t9) {
      const t10 = this.hasZ ? [0, 0, e13.z ?? 0] : [0, 0];
      j7(t10, i10, o7, r9, g2.WGS84), s4.push(t10);
    }
    return s4.push(s4[0]), new j3({ rings: [s4] });
  }
  _createPlanarCircle(e13, r9, t9) {
    const s4 = [], i10 = 2 * Math.PI / t9;
    for (let o7 = 0; o7 < t9; ++o7) {
      const t10 = i10 * o7, c12 = [e13.x + Math.cos(-t10) * r9, e13.y + Math.sin(-t10) * r9];
      this.hasZ && c12.push(e13.z ?? 0), s4.push(c12);
    }
    return s4.push(s4[0]), new j3({ spatialReference: e13.spatialReference, rings: [s4] });
  }
};
r([m({ type: j2 })], g5.prototype, "center", void 0), r([m()], g5.prototype, "geodesic", void 0), r([m()], g5.prototype, "numberOfPoints", void 0), r([m()], g5.prototype, "radius", void 0), r([m()], g5.prototype, "radiusUnit", void 0), g5 = f4 = r([a2("esri.geometry.Circle")], g5);
var b3 = g5;

// node_modules/@arcgis/core/views/draw/support/surfaceCoordinateSystems.js
function w5(t9, r9, e13 = null) {
  return null != e13 ? [t9, r9, e13] : [t9, r9];
}
function g6(t9, r9, e13 = null) {
  return null != e13 ? { x: t9, y: r9, z: e13 } : { x: t9, y: r9 };
}
var R6 = class {
  constructor(t9) {
    this.spatialReference = t9;
  }
  mapToLocalMultiple(r9) {
    return r9.map((t9) => this.mapToLocal(t9)).filter(G);
  }
  get doUnnormalization() {
    return false;
  }
};
var W2 = class extends R6 {
  constructor(t9, a11, o7 = null) {
    super(a11), this._defaultZ = o7, this.transform = e6(), this.transformInv = e6(), this.transform = r5(t9), u6(this.transformInv, this.transform);
  }
  makeMapPoint(t9, r9) {
    return w5(t9, r9, this._defaultZ);
  }
  mapToLocal(t9) {
    return g6(this.transform[0] * t9[0] + this.transform[2] * t9[1] + this.transform[4], this.transform[1] * t9[0] + this.transform[3] * t9[1] + this.transform[5]);
  }
  localToMap(t9) {
    return w5(this.transformInv[0] * t9.x + this.transformInv[2] * t9.y + this.transformInv[4], this.transformInv[1] * t9.x + this.transformInv[3] * t9.y + this.transformInv[5], this._defaultZ);
  }
};
var v = class extends R6 {
  constructor(t9, r9) {
    super(t9.spatialReference), this.view = t9, this.defaultZ = null, this.pWS = n2(), this.tangentFrameUpWS = n2(), this.tangentFrameRightWS = n2(), this.tangentFrameForwardWS = n2(), this.localFrameRightWS = n2(), this.localFrameUpWS = n2(), this.worldToLocalTransform = e3(), this.localToWorldTransform = e3(), this.scale = 1, this.scale = t9.resolution, this.referenceMapPoint = r9, this.defaultZ = r9.hasZ ? r9.z : null;
    const e13 = t9.state.camera.viewRight;
    this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint, this.pWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n.X, this.tangentFrameRightWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n.Y, this.tangentFrameUpWS), this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS, n.Z, this.tangentFrameForwardWS);
    const s4 = n2();
    g3(s4, this.tangentFrameForwardWS, P2(e13, this.tangentFrameForwardWS)), c2(this.localFrameRightWS, e13, s4), A2(this.localFrameRightWS, this.localFrameRightWS), _2(this.localFrameUpWS, this.tangentFrameForwardWS, this.localFrameRightWS), R(this.worldToLocalTransform, this.localFrameRightWS, this.tangentFrameRightWS), L2(this.localToWorldTransform, this.worldToLocalTransform);
  }
  get doUnnormalization() {
    return "global" === this.view.viewingMode;
  }
  makeMapPoint(t9, r9) {
    return w5(t9, r9, this.defaultZ);
  }
  mapToLocal(t9) {
    const r9 = n2();
    this.view.renderCoordsHelper.toRenderCoords(new j2({ x: t9[0], y: t9[1], spatialReference: this.spatialReference }), r9), Q2(r9, r9, this.worldToLocalTransform);
    const e13 = this.view.renderCoordsHelper.fromRenderCoords(r9, new j2({ spatialReference: this.view.spatialReference }));
    return null != e13 ? g6(e13.x / this.scale, e13.y / this.scale) : null;
  }
  localToMap(t9) {
    const r9 = n2();
    this.view.renderCoordsHelper.toRenderCoords(new j2({ x: t9.x * this.scale, y: t9.y * this.scale, spatialReference: this.spatialReference }), r9), Q2(r9, r9, this.localToWorldTransform);
    const e13 = this.view.renderCoordsHelper.fromRenderCoords(r9, new j2({ spatialReference: this.view.spatialReference }));
    return null != e13 ? w5(e13.x, e13.y, this.defaultZ) : null;
  }
};
function F3(t9, r9) {
  if ("2d" === t9.type) return new W2(t9.state.transform, t9.spatialReference, r9.length > 2 ? r9[2] : null);
  if ("3d" === t9.type) {
    const e13 = r9.length > 2 ? new j2({ x: r9[0], y: r9[1], z: r9[2], spatialReference: t9.spatialReference }) : new j2({ x: r9[0], y: r9[1], spatialReference: t9.spatialReference });
    return new v(t9, e13);
  }
  return null;
}

// node_modules/@arcgis/core/views/draw/support/createUtils.js
function g7(t9, e13) {
  const o7 = new j2({ x: t9[0], y: t9[1], spatialReference: e13 });
  return t9.length > 2 && (o7.z = t9[2]), o7;
}
function d6(t9, e13) {
  return new u2({ points: t9, spatialReference: e13 });
}
function R7(t9, e13, o7) {
  const n8 = new P({ paths: t9, spatialReference: e13 });
  return o7 && M(n8), n8;
}
function j10(e13, n8, r9, a11 = true) {
  const l9 = a(e13);
  l9.forEach((e14) => {
    const o7 = e14[0], n9 = e14[e14.length - 1];
    s(o7, n9) && 1 !== e14.length || e14.push(e14[0]);
  });
  let i10 = new j3({ rings: l9, spatialReference: n8 });
  return i10.rings.forEach((t9) => {
    a3(t9) || t9.reverse();
  }), r9 && M(i10), a11 && i10.isSelfIntersecting && N(n8) && (i10 = y2(i10)), i10;
}
function T2(t9, o7, n8) {
  const r9 = o7.mapToLocalMultiple(t9), a11 = [], l9 = { x: r9[0].x, y: r9[0].y }, s4 = { x: r9[1].x, y: r9[1].y }, i10 = Math.round(s4.x - l9.x), c12 = Math.round(s4.y - l9.y), y6 = Math.max(Math.abs(i10), Math.abs(c12));
  if (n8) {
    const t10 = { x: l9.x + y6, y: l9.y + y6 }, e13 = { x: l9.x - y6, y: l9.y - y6 };
    a11.push(g6(t10.x, e13.y), g6(e13.x, e13.y), g6(e13.x, t10.y), g6(t10.x, t10.y));
  } else {
    const t10 = { x: i10 > 0 ? l9.x + y6 : l9.x - y6, y: c12 > 0 ? l9.y + y6 : l9.y - y6 };
    a11.push(g6(l9.x, l9.y), g6(t10.x, l9.y), g6(t10.x, t10.y), g6(l9.x, t10.y));
  }
  return U(j10([a11.map((t10) => o7.localToMap(t10)).filter(G)], o7.spatialReference, o7.doUnnormalization, true), a11, o7);
}
function b4(t9, o7, n8) {
  let r9 = o7.mapToLocalMultiple(t9);
  if (1 === r9.length) {
    const t10 = 48, e13 = r9[0];
    r9 = [g6(e13.x - t10, e13.y + t10), g6(e13.x + t10, e13.y - t10), g6(e13.x + t10, e13.y - t10), g6(e13.x - t10, e13.y + t10)];
  }
  const a11 = [], l9 = { x: r9[0].x, y: r9[0].y }, s4 = { x: r9[1].x, y: r9[1].y };
  if (n8) {
    const t10 = Math.round(s4.x - l9.x), e13 = Math.round(s4.y - l9.y);
    a11.push(g6(l9.x - t10, l9.y - e13), g6(s4.x, l9.y - e13), g6(s4.x, s4.y), g6(l9.x - t10, s4.y));
  } else a11.push(g6(l9.x, l9.y), g6(s4.x, l9.y), g6(s4.x, s4.y), g6(l9.x, s4.y));
  return U(j10([a11.map((t10) => o7.localToMap(t10)).filter(G)], o7.spatialReference, o7.doUnnormalization, true), a11, o7);
}
function U(t9, e13, o7) {
  const n8 = P4(e13[3], e13[2], o7), r9 = P4(e13[1], e13[2], o7), a11 = P4(e13[0], e13[1], o7), l9 = P4(e13[0], e13[3], o7);
  return { geometry: t9, midpoints: null != n8 && null != r9 && null != a11 && null != l9 ? { top: n8, right: r9, bottom: a11, left: l9 } : null };
}
function P4(t9, e13, o7) {
  w6[0] = t9.x, w6[1] = t9.y, w6[2] = 0, I2[0] = e13.x, I2[1] = e13.y, I2[2] = 0, I(w6, w6, I2, 0.5), z2.x = w6[0], z2.y = I2[1], z2.z = I2[2];
  const n8 = o7.localToMap(z2);
  return null != n8 ? g7(n8, o7.spatialReference) : null;
}
var z2 = g6(0, 0, 0);
var w6 = n2();
var I2 = n2();
function L3(t9, e13, o7, r9) {
  const a11 = e13.mapToLocalMultiple(t9);
  let s4 = null, c12 = null;
  if (o7) s4 = a11[0], c12 = a11[1];
  else {
    const t10 = a11[0], e14 = a11[1], o8 = Math.round(e14.x - t10.x), n8 = Math.round(e14.y - t10.y), r10 = Math.max(Math.abs(o8), Math.abs(n8));
    s4 = g6(o8 > 0 ? t10.x + r10 / 2 : t10.x - r10 / 2, n8 > 0 ? t10.y + r10 / 2 : t10.y - r10 / 2), c12 = g6(Math.abs(o8) > Math.abs(n8) ? s4.x - r10 / 2 : s4.x, Math.abs(o8) > Math.abs(n8) ? s4.y : s4.y - r10 / 2);
  }
  const y6 = e13.localToMap(s4), p7 = e13.localToMap(c12);
  if (null == y6 || null == p7) return null;
  e13.doUnnormalization && z([[y6, p7]], e13.spatialReference);
  const u10 = g7(y6, e13.spatialReference), m7 = g7(p7, e13.spatialReference), f8 = Q(e13.spatialReference);
  let d9 = 0;
  if (N(e13.spatialReference)) d9 = f8 * l4(u10, m7, null);
  else {
    const t10 = s4.x - c12.x, e14 = s4.y - c12.y;
    d9 = f8 * Math.sqrt(t10 * t10 + e14 * e14) * (r9 || 1);
  }
  const R11 = new b3({ center: u10, radius: d9, radiusUnit: "meters", spatialReference: e13.spatialReference });
  return { geometry: j10(R11.rings, R11.spatialReference, false), center: u10, edge: m7 };
}
function v2(t9, o7, n8) {
  const r9 = o7.mapToLocalMultiple(t9), a11 = r9[0], l9 = r9[1], s4 = Math.round(l9.x - a11.x), i10 = Math.round(l9.y - a11.y), c12 = g6(n8 ? a11.x : a11.x + s4 / 2, n8 ? a11.y : a11.y + i10 / 2), y6 = n8 ? s4 : s4 / 2, p7 = n8 ? i10 : i10 / 2, u10 = 60, m7 = [], f8 = 2 * Math.PI / u10;
  function x6(t10) {
    const e13 = Math.cos(t10), o8 = Math.sin(t10);
    return g6(y6 * e13 + c12.x, p7 * o8 + c12.y);
  }
  for (let e13 = 0; e13 < u10; e13++) m7.push(x6(e13 * f8));
  m7.push(m7[0]);
  const { spatialReference: h9, doUnnormalization: d9 } = o7, R11 = j10([m7.map((t10) => o7.localToMap(t10)).filter(G)], h9, d9, false), T6 = o7.localToMap(x6(Math.PI / 2)), b7 = o7.localToMap(x6(0)), U5 = o7.localToMap(x6(-Math.PI / 2)), P8 = o7.localToMap(x6(Math.PI));
  return { geometry: R11, midpoints: null != T6 && null != b7 && null != U5 && null != P8 ? { top: g7(T6, h9), right: g7(b7, h9), bottom: g7(U5, h9), left: g7(P8, h9) } : null };
}

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils.js
function e11(e13, i10, a11) {
  if (null == e13) return "noTool";
  switch (e13) {
    case "point":
      return n7();
    case "multipoint":
      return "multipoint";
    case "polyline":
      return r8(i10, a11);
    case "polygon":
      return t7(i10, a11);
    case "rectangle":
    case "circle":
      return l7(i10, a11);
    default:
      return;
  }
}
function n7(e13) {
  return "point";
}
function r8(e13, n8) {
  const r9 = null != e13 && "polyline" === e13.type && e13.paths.length ? e13.paths[0].length : 0;
  return "freehand" === n8 ? r9 < 2 ? "freehandStart" : "freehandEnd" : r9 < 2 ? "polylineZeroVertices" : "polylineOneVertex";
}
function t7(e13, n8) {
  const r9 = null != e13 && "polygon" === e13.type && e13.rings.length ? e13.rings[0].length : 0;
  if (r9 < 3) switch (n8) {
    case "freehand":
      return "freehandStart";
    case "hybrid":
      return "polygonZeroVerticesHybrid";
    default:
      return "polygonZeroVertices";
  }
  else if (r9 < 4) return "freehand" === n8 ? "freehandEnd" : "polygonOneVertex";
  return "polygonTwoVertices";
}
function l7(e13, n8) {
  if ((null != e13 && "polygon" === e13.type && e13.rings.length ? e13.rings[0].length : 0) < 3) switch (n8) {
    case "freehand":
      return "freehandStart";
    case "click":
      return "shapeStartClick";
    default:
      return "shapeStartHybrid";
  }
  switch (n8) {
    case "freehand":
      return "freehandEnd";
    case "click":
      return "shapeEndClick";
    default:
      return "shapeEndHybrid";
  }
}

// node_modules/@arcgis/core/views/draw/support/helpMessageUtils3d.js
function i5(o7, i10) {
  const l9 = o7 == null ? void 0 : o7.geometry;
  if (!o7 || "mesh" !== (l9 == null ? void 0 : l9.type) || !i10) return;
  const { renderCoordsHelper: p7, elevationProvider: u10 } = i10, { camera: h9 } = i10.state, { extent: d9 } = l9, { center: x6, spatialReference: g10 } = d9, v6 = Q(g10), j12 = $(g10), z7 = Q(p7.spatialReference), y6 = d9.width * v6, C4 = d9.height * j12, R11 = (d9.zmax ?? 0) * j12, U5 = R11 - (d9.zmin ?? 0) * j12, b7 = Math.max(y6, C4, U5) / z7, { x: w8, y: P8 } = x6, S6 = x6.z ?? 0;
  o2(f5, w8, P8, S6), p7.toRenderCoords(f5, g10, f5);
  const T6 = b7 / h9.computeScreenPixelSizeAt(f5);
  if (T6 > h9.width * a10) return "meshTooClose";
  if (T6 < m4) return "meshTooFar";
  const k6 = a4(o7), { absoluteZ: A7 } = b2(w8, P8, R11, g10, i10, k6);
  return A7 < (u10.getElevation(w8, P8, S6, g10, "ground") ?? 0) * j12 + U5 * c8 ? "meshUnderground" : "mesh";
}
var m4 = 20;
var a10 = 1;
var c8 = 0.1;
var f5 = n2();

// node_modules/@arcgis/core/views/interactive/sketch/constraintUtils.js
function Z(e13, n8, t9, r9, o7, i10) {
  let l9 = "geodesic", u10 = N2(t9);
  const s4 = c4();
  return E2(e13, n8, r9, s4), s4[2] = 0, u10 && n3(s4, t9, s4, u10) || (l9 = "euclidean", u10 = t9), { mode: l9, view: n8, elevationInfo: r9, hasZ: o7, directionMode: i10, spatialReference: e13.spatialReference, measurementSR: u10, origin: s4 };
}
function b5(n8, t9, r9) {
  if (null == t9 || null == n8) return;
  const i10 = ie(r9.measurementSR);
  if (null == i10) return;
  const l9 = G2(n8, r9);
  if (null == l9) return;
  const u10 = f3(t9, i10);
  return new yt(l9, u10);
}
function A3(e13, n8, r9, o7) {
  if (null == r9 || null == e13) return;
  const i10 = G2(e13, o7);
  if (null == i10) return;
  const l9 = T(r9), u10 = 10, s4 = (e14) => {
    if (null == e14) return;
    const n9 = c4(), r10 = o4(e14, "degrees", "geographic");
    return M3(n9, i10, o7.measurementSR, u10, r10, o7.mode) ? new Et(i10, n9) : void 0;
  }, c12 = () => {
    if (null != n8 && null != e13) return T(R2(n8, e13));
  };
  switch (o7.directionMode) {
    case j8.Absolute:
      return s4(l9);
    case j8.Relative: {
      const e14 = c12();
      if (null == e14) return;
      return s4(e14 + l9);
    }
    case j8.RelativeBilateral: {
      const e14 = c12();
      if (null == e14) return;
      return ge([s4(e14 + l9), s4(e14 - l9)]);
    }
  }
}
function B(e13, n8) {
  const t9 = C2(e13, n8);
  return null != t9 ? new qt(t9) : void 0;
}
function P5(e13, n8, t9) {
  const { context: r9, longitude: o7, latitude: i10, direction: l9, distance: u10, elevation: s4 } = t9;
  if (null != o7 || null != i10 || null != u10 || null != s4 || null != l9) {
    if (null != o7 || null != i10) {
      const e14 = T(o7), n9 = T(i10), t10 = C2(s4, r9);
      return new Ut(e14, n9, t10);
    }
    return T3(e13, n8, t9);
  }
}
function T3(n8, t9, { context: r9, direction: o7, distance: i10, elevation: l9 }) {
  if (null == t9) return B(l9, r9);
  const { view: u10, elevationInfo: s4, measurementSR: a11 } = r9, f8 = E2(t9, u10, s4);
  if (!a11 || !n3(f8, t9.spatialReference, E4, a11)) return;
  const [m7, d9] = E4, v6 = null != i10 ? f3(i10, "meters") : void 0, g10 = T(o7), j12 = C2(l9, r9), h9 = (e13) => {
    const n9 = new Zt([m7, d9], a11, v6, j12, e13);
    return null == v6 || null == e13 || null == j12 && r9.hasZ ? n9 : new gt(n9.closestTo(f8));
  };
  if (null == g10) return h9(void 0);
  const x6 = () => {
    if (null != n8 && null != t9) return T(R2(n8, t9));
  };
  switch (r9.directionMode) {
    case j8.Absolute:
      return h9(g10);
    case j8.Relative: {
      const e13 = x6();
      if (null == e13) return;
      return h9(e13 + g10);
    }
    case j8.RelativeBilateral: {
      const e13 = x6();
      if (null == e13) return;
      return ge([h9(e13 + g10), h9(e13 - g10)]);
    }
  }
}
function V4(e13) {
  return "geodesic" === e13.context.mode ? P5(null, null, e13) : q(e13);
}
function k5(e13, n8, t9) {
  const { context: r9, x: o7, y: i10, distance: l9, direction: u10, elevation: s4 } = t9;
  return "geodesic" === r9.mode ? P5(n8, e13, t9) : null != o7 || null != i10 ? q(t9) : z3([b5(e13, l9, r9), A3(e13, n8, u10, r9), B(s4, r9)]);
}
function q({ x: e13, y: n8, elevation: t9, context: r9 }) {
  J2.x = (e13 == null ? void 0 : e13.value) ?? 0, J2.y = (n8 == null ? void 0 : n8.value) ?? 0, J2.spatialReference = r9.spatialReference;
  const o7 = G2(J2, r9, F4);
  return new Ut(null != e13 && null != o7 ? o7[0] : void 0, null != n8 && null != o7 ? o7[1] : void 0, C2(t9, r9));
}
function z3(e13) {
  let n8;
  for (const t9 of e13) t9 && (n8 = (n8 == null ? void 0 : n8.intersect(t9)) ?? t9);
  return n8;
}
function G2(e13, n8, t9 = c4()) {
  const { view: r9, elevationInfo: o7, measurementSR: l9, origin: u10, mode: s4 } = n8;
  if (E2(e13, r9, o7, t9), n3(t9, e13.spatialReference, t9, l9)) return "geodesic" !== s4 && c2(t9, t9, u10), t9;
}
function W3(e13, n8, t9, r9) {
  const { view: o7, measurementSR: i10, spatialReference: s4, origin: a11, mode: f8 } = t9;
  if ("geodesic" === f8 ? s3(H, e13) : u3(H, e13, a11), n3(H, i10, H, s4)) return h4(H, o7, n8, t9, r9);
}
function C2(e13, n8) {
  var _a;
  return ((_a = D(e13, n8)) == null ? void 0 : _a.value) ?? void 0;
}
function D(t9, { view: o7, origin: i10, elevationInfo: l9, hasZ: u10, measurementSR: s4 }) {
  if (null == t9 || !u10) return;
  const c12 = ne(s4);
  if (null == c12) return;
  const [a11, f8] = i10, d9 = f3(t9, c12), p7 = "3d" === (o7 == null ? void 0 : o7.type) ? E(o7, a11, f8, d9, s4, l9) : d9;
  return null != p7 ? a6(p7, c12) : void 0;
}
var E4 = c4();
var F4 = c4();
var H = c4();
var J2 = e5(0, 0, 0, g2.WGS84);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawCircleTooltipInfo.js
var i6 = class extends r6 {
  constructor(o7) {
    super(o7), this.type = "draw-circle", this.radius = null, this.xSize = null, this.ySize = null, this.area = d4;
  }
  get allFields() {
    return [];
  }
};
r([m()], i6.prototype, "type", void 0), r([m()], i6.prototype, "radius", void 0), r([m()], i6.prototype, "xSize", void 0), r([m()], i6.prototype, "ySize", void 0), r([m()], i6.prototype, "area", void 0), r([m()], i6.prototype, "helpMessage", void 0), r([m()], i6.prototype, "allFields", null), i6 = r([a2("esri.views.interactive.tooltip.infos.DrawCircleTooltipInfo")], i6);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMeshTooltipInfo.js
var p3 = class extends h5(r6) {
  constructor(o7) {
    super(o7), this.type = "draw-mesh", this.orientation = k4({ lockable: false }), this.scale = R4({ lockable: false });
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation, this.orientation, this.scale];
  }
};
r([m()], p3.prototype, "helpMessage", void 0), r([m()], p3.prototype, "allFields", null), p3 = r([a2("esri.views.interactive.tooltip.infos.DrawMeshTooltipInfo")], p3);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawMultipointTooltipInfo.js
var i7 = class extends h5(r6) {
  constructor(o7) {
    super(o7), this.type = "draw-multipoint";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
r([m()], i7.prototype, "helpMessage", void 0), r([m()], i7.prototype, "allFields", null), i7 = r([a2("esri.views.interactive.tooltip.infos.DrawMultipointTooltipInfo")], i7);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPointTooltipInfo.js
var i8 = class extends h5(r6) {
  constructor(o7) {
    super(o7), this.type = "draw-point";
  }
  get allFields() {
    return [this.longitude, this.latitude, this.x, this.y, this.elevation];
  }
};
r([m()], i8.prototype, "helpMessage", void 0), r([m()], i8.prototype, "allFields", null), i8 = r([a2("esri.views.interactive.tooltip.infos.DrawPointTooltipInfo")], i8);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolygonTooltipInfo.js
var c9 = class extends h5(r6) {
  constructor(o7) {
    super(o7), this.type = "draw-polygon", this.direction = y3(), this.distance = F2(), this.area = Q3(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.area];
  }
};
r([m()], c9.prototype, "xyMode", void 0), r([m()], c9.prototype, "helpMessage", void 0), r([m()], c9.prototype, "allFields", null), c9 = r([a2("esri.views.interactive.tooltip.infos.DrawPolygonTooltipInfo")], c9);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawPolylineTooltipInfo.js
var c10 = class extends h5(r6) {
  constructor(t9) {
    super(t9), this.type = "draw-polyline", this.direction = y3(), this.distance = F2(), this.totalLength = w4(), this.xyMode = "direction-distance";
  }
  get allFields() {
    return [this.direction, this.distance, this.longitude, this.latitude, this.x, this.y, this.elevation, this.totalLength];
  }
};
r([m()], c10.prototype, "helpMessage", void 0), r([m()], c10.prototype, "xyMode", void 0), r([m()], c10.prototype, "allFields", null), c10 = r([a2("esri.views.interactive.tooltip.infos.DrawPolylineTooltipInfo")], c10);

// node_modules/@arcgis/core/views/interactive/tooltip/infos/DrawRectangleTooltipInfo.js
var p4 = class extends r6 {
  constructor(o7) {
    super(o7), this.type = "draw-rectangle", this.xSize = h3, this.ySize = h3, this.area = d4;
  }
  get allFields() {
    return [];
  }
};
r([m()], p4.prototype, "type", void 0), r([m()], p4.prototype, "xSize", void 0), r([m()], p4.prototype, "ySize", void 0), r([m()], p4.prototype, "area", void 0), r([m()], p4.prototype, "helpMessage", void 0), r([m()], p4.prototype, "allFields", null), p4 = r([a2("esri.views.interactive.tooltip.infos.DrawRectangleTooltipInfo")], p4);

// node_modules/@arcgis/core/views/draw/support/tooltipUtils.js
function T4(e13, t9) {
  return { point: new i8({ sketchOptions: t9, viewType: e13 }), multipoint: new i7({ sketchOptions: t9, viewType: e13 }), polyline: new c10({ sketchOptions: t9, viewType: e13 }), polygon: new c9({ sketchOptions: t9, viewType: e13 }), mesh: new p3({ sketchOptions: t9, viewType: e13 }), rectangle: new p4({ sketchOptions: t9 }), circle: new i6({ sketchOptions: t9 }) };
}
function b6(e13) {
  const { directionOptions: t9, geometryType: o7, sketchOptions: n8, tooltipInfos: i10 } = e13, r9 = (t10) => {
    const o8 = N4(e13).mode, n9 = i10[t10].elevation;
    "relative-to-ground" === o8 || "relative-to-scene" === o8 || "on-the-ground" === o8 ? n9.lock(W4(e13)) : n9.unlock();
  }, l9 = (e14) => {
    if (t9) {
      const o8 = i10[e14].direction;
      o8.committed = t9.angle, o8.unlockOnVertexPlacement = false, n8.values.directionMode = t9.mode;
    }
  };
  switch (o7) {
    case "polygon":
    case "polyline":
      r9(o7), l9(o7);
      break;
    case "point":
    case "mesh":
      r9(o7);
  }
}
function I3(e13, t9) {
  const { drawOperation: o7, view: n8 } = t9, i10 = V5(t9), r9 = N4(t9);
  if ("2d" === n8.type || !e13 || "absolute-height" !== r9.mode || 1 !== (o7 == null ? void 0 : o7.numCommittedVertices) || !i10 || "draw-polyline" !== i10.type && "draw-polygon" !== i10.type || i10.elevation.locked) return;
  const [l9, c12, a11] = e13, s4 = K2(l9, c12, a11, r9, t9);
  null != s4 && i10.elevation.lock(s4);
}
function U2(e13) {
  var _a;
  (_a = V5(e13)) == null ? void 0 : _a.allFields.forEach((e14) => {
    e14.unlockOnVertexPlacement && e14.unlock();
  });
}
function V5({ geometryType: e13, graphic: t9, tooltipInfos: o7 }) {
  var _a;
  return ((_a = t9 == null ? void 0 : t9.geometry) == null ? void 0 : _a.type) !== P6[e13] ? "circle" === e13 || "rectangle" === e13 ? o7[e13] : null : o7[e13];
}
var P6 = { point: "point", multipoint: "multipoint", mesh: "mesh", polyline: "polyline", polygon: "polygon", circle: "polygon", rectangle: "polygon", freehandPolygon: "polygon", freehandPolyline: "polyline" };
function D2(e13, t9) {
  switch (e13 == null ? void 0 : e13.type) {
    case "draw-point":
      G3(e13, t9);
      break;
    case "draw-multipoint":
      L4(e13, t9);
      break;
    case "draw-polyline":
      Z2(e13, t9);
      break;
    case "draw-polygon":
      C3(e13, t9);
      break;
    case "draw-rectangle":
      H2(e13, t9);
      break;
    case "draw-circle":
      R8(e13, t9);
      break;
    case "draw-mesh":
      z4(e13, t9);
  }
}
function G3(e13, t9) {
  var _a;
  const o7 = (_a = t9.graphic) == null ? void 0 : _a.geometry;
  "point" === (o7 == null ? void 0 : o7.type) && (S2(e13, o7, t9), e13.helpMessage = e11("point", o7, t9.drawOperation.drawingMode));
}
function L4(e13, t9) {
  var _a;
  const o7 = (_a = t9.graphic) == null ? void 0 : _a.geometry;
  "multipoint" === (o7 == null ? void 0 : o7.type) && (S2(e13, o7, t9), e13.helpMessage = e11("multipoint", o7, t9.drawOperation.drawingMode));
}
function z4(e13, t9) {
  const { graphic: o7, view: n8 } = t9, i10 = o7 == null ? void 0 : o7.geometry;
  "3d" !== n8.type || i10 && "mesh" !== i10.type || (S2(e13, i10 == null ? void 0 : i10.origin, t9), i10 && V3(e13, i10), e13.helpMessage = i5(o7, n8));
}
function S2(e13, t9, o7) {
  const { drawOperation: n8, view: i10, sketchOptions: r9 } = o7, { cursorVertex: l9 } = n8;
  e13.sketchOptions = r9, e13.viewType = i10.type;
  const c12 = "multipoint" === (t9 == null ? void 0 : t9.type) ? t9.getPoint(t9.points.length - 1) : t9;
  if (e13.setLocationFromPoint(c12, Q4(o7)), q2(e13.elevation, o7), !l9) return void (n8.constraints = void 0);
  const a11 = l9;
  n8.constraints = { context: $2(a11, o7), x: e13.x.committed, y: e13.y.committed, longitude: e13.longitude.committed, latitude: e13.latitude.committed, elevation: e13.elevation.committed, distance: null, direction: null };
}
function Z2(t9, o7) {
  const { createOperationGeometry: n8, drawOperation: i10 } = o7, r9 = null != n8 ? n8.full : null;
  r9 && "polyline" !== r9.type || (F5(t9, o7), t9.totalLength.actual = i10.lastVertex ? (r9 ? c5(r9) : null) ?? h3 : null, t9.helpMessage = e11("polyline", r9, o7.drawOperation.drawingMode));
}
function C3(e13, o7) {
  const { createOperationGeometry: n8, drawOperation: i10 } = o7, r9 = null != n8 ? n8.full : null;
  r9 && "polygon" !== r9.type || (F5(e13, o7), e13.area.actual = i10.lastVertex ? (r9 ? u7(r9) : null) ?? d4 : null, e13.helpMessage = e11("polygon", r9, o7.drawOperation.drawingMode));
}
function F5(t9, n8) {
  const { drawOperation: i10, sketchOptions: r9, view: l9 } = n8, { cursorVertex: c12, lastVertex: a11, secondToLastVertex: s4 } = i10, p7 = r9.values.effectiveDirectionMode;
  t9.sketchOptions = r9, t9.viewType = l9.type;
  const u10 = a11 && c12 ? m3(a11, c12) ?? h3 : null;
  if (t9.distance.actual = u10, t9.distance.readOnly = null == a11, t9.direction.actual = null, t9.direction.readOnly = true, a11 && c12 && ("absolute" === p7 || s4)) {
    const e13 = x3(s4, a11, c12, p7);
    t9.direction.actual = e13 ?? j6, t9.direction.readOnly = false;
  }
  t9.setLocationFromPoint(c12, Q4(n8)), q2(t9.elevation, n8);
  const d9 = A4(a11, n8);
  t9.xyMode = d9, t9.direction.visible = "direction-distance" === d9, t9.distance.visible = "direction-distance" === d9, t9.effectiveX.visible = "coordinates" === d9, t9.effectiveY.visible = "coordinates" === d9;
  const m7 = c12 ?? a11;
  i10.constraints = m7 ? { context: $2(m7, n8), x: t9.x.committed, y: t9.y.committed, longitude: t9.longitude.committed, latitude: t9.latitude.committed, elevation: t9.elevation.committed, distance: t9.distance.committed, direction: t9.direction.committed } : void 0;
}
function A4(e13, { sketchOptions: t9 }) {
  const o7 = t9.tooltips.xyMode;
  return "auto" === o7 ? e13 ? "direction-distance" : "coordinates" : o7;
}
function H2(e13, t9) {
  var _a;
  e13.sketchOptions = t9.sketchOptions, e13.xSize = X(t9), e13.ySize = Y2(t9), e13.area = E5(t9), e13.helpMessage = e11("rectangle", (_a = t9.graphic) == null ? void 0 : _a.geometry, t9.drawOperation.drawingMode);
}
function R8(e13, t9) {
  var _a;
  const { forceUniformSize: o7, sketchOptions: n8 } = t9;
  e13.sketchOptions = n8, e13.radius = o7 ? B2(t9) : null, e13.xSize = o7 ? null : X(t9), e13.ySize = o7 ? null : Y2(t9), e13.area = E5(t9), e13.helpMessage = e11("circle", (_a = t9.graphic) == null ? void 0 : _a.geometry, t9.drawOperation.drawingMode);
}
function q2(e13, t9) {
  const { drawOperation: o7 } = t9, n8 = (o7 == null ? void 0 : o7.cursorVertex) ?? (o7 == null ? void 0 : o7.lastVertex);
  e13.actual = R5(n8) ?? W4(t9), e13.visible = o7.hasZ, e13.readOnly = false, e13.showAsZ = true;
}
function E5(e13) {
  var _a;
  const o7 = (_a = e13.createOperationGeometry) == null ? void 0 : _a.full;
  return "polygon" !== (o7 == null ? void 0 : o7.type) ? d4 : u7(o7) ?? d4;
}
function X(t9) {
  var _a, _b;
  const o7 = (_b = (_a = t9.createOperationGeometry) == null ? void 0 : _a.rectangle) == null ? void 0 : _b.midpoints;
  return (null != o7 ? m3(o7.left, o7.right) : null) ?? h3;
}
function Y2(t9) {
  var _a, _b;
  const o7 = (_b = (_a = t9.createOperationGeometry) == null ? void 0 : _a.rectangle) == null ? void 0 : _b.midpoints;
  return (null != o7 ? m3(o7.top, o7.bottom) : null) ?? h3;
}
function B2({ createOperationGeometry: t9 }) {
  var _a;
  return (null != ((_a = t9 == null ? void 0 : t9.circle) == null ? void 0 : _a.center) && null != t9.circle.edge ? m3(t9.circle.center, t9.circle.edge) : null) ?? h3;
}
function J3(e13) {
  const { geometryType: t9, tooltipInfos: o7 } = e13;
  switch (t9) {
    case "point":
    case "multipoint":
    case "mesh":
    case "polyline":
    case "polygon": {
      const i10 = o7[t9].elevation.committed;
      if (!i10) return;
      return f3(i10, "meters") / $(Q4(e13));
    }
    default:
      return;
  }
}
function K2(e13, t9, o7, n8, i10) {
  const { view: r9, drawOperation: c12 } = i10;
  if ("3d" !== r9.type || !c12) return;
  o7 ?? (o7 = 0);
  const a11 = Q4(i10), s4 = N4(i10), p7 = E(r9, e13, t9, o7, a11, s4, n8);
  return j9(p7, a11) ?? W4(i10);
}
function N4(e13) {
  return e13.drawOperation.elevationInfo ?? j5;
}
function Q4(e13) {
  return e13.drawOperation.coordinateHelper.spatialReference;
}
function W4(e13) {
  const t9 = $(Q4(e13));
  return a6(e13.defaultZ * t9, "meters");
}
function $2(e13, t9) {
  return Z(e13, t9.view, Q4(t9), N4(t9), t9.drawOperation.coordinateHelper.hasZ(), t9.sketchOptions.values.effectiveDirectionMode);
}

// node_modules/@arcgis/core/views/draw/DrawGraphicTool.js
var I4 = class extends i2.EventedMixin(n4) {
  constructor(t9) {
    super(t9), this._graphic = null, this._coordinateFormatterLoadTask = null, this._createOperationGeometry = null, this.defaultZ = 0, this.directionOptions = null, this.elevationLockOnVertexAddDisabled = false, this.geometryType = null, this.hasZ = true, this.geometryToPlace = null, this.snappingManager = null, this.snapToScene = false, this.sketchOptions = new l5();
  }
  initialize() {
    const { view: t9 } = this;
    this.internalGraphicsLayer = new h({ listMode: "hide", internal: true }), this.view.map.layers.add(this.internalGraphicsLayer);
    const e13 = this.drawOperation = this.makeDrawOperation();
    this.tooltipInfos = T4(t9.type, this.sketchOptions);
    const o7 = R3(() => ({ view: t9, options: this.sketchOptions.tooltips }));
    this.tooltip = o7, b6(this._tooltipsContext), this._coordinateFormatterLoadTask = d2(() => w3()), this.addHandles([e13.on("vertex-add", (t10) => this.onVertexAdd(t10)), e13.on("vertex-remove", (t10) => this.onVertexRemove(t10)), e13.on("vertex-update", (t10) => this.onVertexUpdate(t10)), e13.on("cursor-update", (t10) => this.onCursorUpdate(t10)), e13.on("cursor-remove", () => this._updateGraphic()), e13.on("complete", (t10) => this.onComplete(t10)), this._coordinateFormatterLoadTask, o7.on("paste", (t10) => J(t10, this.activeTooltipInfo)), d3(() => this.cursor, (t10) => {
      e13.cursor = t10;
    }, A), i(() => {
      const { activeTooltipInfo: t10, sketchOptions: e14 } = this;
      D2(t10, this._tooltipsContext), o7.info = e14.tooltips.effectiveEnabled ? t10 : null;
    }), i(() => {
      e13.constraintZ = J3(this._tooltipsContext);
    }, C)]), this.finishToolCreation();
  }
  destroy() {
    this.drawOperation = u(this.drawOperation), this.tooltip = u(this.tooltip), this._destroyAllVisualizations(), this.view.map.remove(this.internalGraphicsLayer), this.internalGraphicsLayer = u(this.internalGraphicsLayer), this._set("view", null);
  }
  get _drawSpatialReference() {
    return this.drawOperation.coordinateHelper.spatialReference;
  }
  get _tooltipsContext() {
    return { createOperationGeometry: this._createOperationGeometry, defaultZ: this.defaultZ, directionOptions: this.directionOptions, drawOperation: this.drawOperation, forceUniformSize: this.forceUniformSize, geometryType: this.geometryType, graphic: this.graphic, sketchOptions: this.sketchOptions, tooltipInfos: this.tooltipInfos, view: this.view };
  }
  get canRedo() {
    return this.drawOperation.canRedo;
  }
  get canUndo() {
    return this.drawOperation.canUndo;
  }
  set centered(t9) {
    this._set("centered", t9), this._updateGraphic();
  }
  get cursor() {
    return this._get("cursor");
  }
  set cursor(t9) {
    this._set("cursor", t9);
  }
  set enabled(t9) {
    this.drawOperation.interactive = t9, this._set("enabled", t9);
  }
  set forceUniformSize(t9) {
    this._set("forceUniformSize", t9), this._updateGraphic();
  }
  get graphic() {
    return this._graphic;
  }
  set graphicSymbol(t9) {
    this._set("graphicSymbol", t9), null != this._graphic && (this._graphic.symbol = t9);
  }
  set mode(t9) {
    const e13 = this.drawOperation;
    e13 && (e13.drawingMode = t9), this._set("mode", t9);
  }
  get updating() {
    var _a;
    return ((_a = this.drawOperation) == null ? void 0 : _a.updating) ?? false;
  }
  get undoRedo() {
    const { view: { type: t9, map: e13 } } = this;
    return "2d" === t9 && e13 && "undoRedo" in e13 && e13.undoRedo instanceof u8 ? e13.undoRedo : null;
  }
  set undoRedo(t9) {
    this._override("undoRedo", t9);
  }
  completeCreateOperation() {
    this.drawOperation.complete();
  }
  onInputEvent(t9) {
    this.destroyed || O2(t9, this.tooltip) || this.drawOperation.onInputEvent(t9);
  }
  redo() {
    this.drawOperation.redo();
  }
  reset() {
  }
  undo() {
    this.drawOperation.undo(), 0 === this.drawOperation.numCommittedVertices && b6(this._tooltipsContext);
  }
  _destroyAllVisualizations() {
    this.removeHandles(F6.outline), this.removeHandles(F6.regularVertices), this.removeHandles(F6.activeVertex), this.removeHandles(F6.activeEdge), this.removeHandles(A5);
  }
  _createOrUpdateGraphic(t9) {
    if (null != this._graphic) return this.updateGraphicGeometry(t9), this._graphic;
    const o7 = new b({ ...this.graphicProperties, symbol: this.graphicSymbol });
    return this._graphic = o7, this.updateGraphicGeometry(t9), this.internalGraphicsLayer.add(o7), this.addHandles(this.initializeGraphic(o7)), this.notifyChange("graphic"), this.addHandles(e(() => {
      this.internalGraphicsLayer.remove(o7), this._graphic === o7 && (this._graphic = null);
    }), A5), o7;
  }
  updateGraphicGeometry(t9) {
    this._graphic.geometry = t9;
  }
  _getCreateOperationGeometry(t9 = { operationComplete: false }) {
    var _a, _b;
    if (null == this.drawOperation) return;
    const { coordinateHelper: e13, view: o7, visualizationCursorVertex: r9, lastVertex: i10, committedVertices: s4, geometryIncludingUncommittedVertices: n8, numCommittedVertices: a11 } = this.drawOperation;
    if (!(a11 > 0 || null != r9)) return;
    const l9 = t9.operationComplete ? s4 : n8, p7 = l9.length, c12 = null != r9 ? e13.pointToArray(r9) : null, h9 = this._drawSpatialReference, d9 = "3d" === o7.type && "global" === o7.viewingMode, u10 = new l6();
    u10.committedVertices = s4, u10.cursorVertex = c12;
    const { geometryType: x6 } = this;
    switch (x6) {
      case "point":
      case "mesh":
        u10.full = e13.arrayToPoint(l9[0]);
        break;
      case "multipoint":
        u10.full = p7 > 0 ? d6(l9, h9) : null;
        break;
      case "polyline":
      case "polygon":
        p7 > 0 && (u10.full = "polygon" === x6 ? j10([l9], h9, d9, true) : R7([l9], h9, d9), u10.cursorEdge = null != c12 && i10 && !a5(r9, i10) ? R7([[c12, e13.pointToArray(i10)]], h9, d9) : null, u10.outline = p7 > 1 ? u10.full : null);
        break;
      case "circle":
      case "rectangle": {
        if (u10.committedVertices = u10.cursorVertex = null, !p7) break;
        const e14 = F3(o7, l9[0]), r10 = l9[0], i11 = e14.makeMapPoint(r10[0] + Z3 * o7.resolution, r10[1]);
        "circle" === x6 ? 1 === p7 && t9.operationComplete ? u10.circle = L3([r10, i11], e14, true) : 2 === p7 && (this.forceUniformSize ? u10.circle = L3(l9, e14, this.centered) : u10.rectangle = v2(l9, e14, this.centered)) : 1 === p7 && t9.operationComplete ? u10.rectangle = T2([r10, i11], e14, true) : 2 === p7 && (u10.rectangle = this.forceUniformSize ? T2(l9, e14, this.centered) : b4(l9, e14, this.centered)), u10.full = null != u10.circle ? u10.circle.geometry : (_a = u10.rectangle) == null ? void 0 : _a.geometry, u10.outline = "polygon" === ((_b = u10.full) == null ? void 0 : _b.type) ? u10.full : null;
        break;
      }
      default:
        return null;
    }
    return u10;
  }
  initializeGraphic(t9) {
    return e();
  }
  onComplete(t9) {
    if (!this.drawOperation) return;
    this._updateGraphic();
    let e13 = null;
    if (this.drawOperation.isCompleted) {
      const t10 = this._getCreateOperationGeometry({ operationComplete: true });
      null != t10 && (e13 = this._createOrUpdateGraphic(t10.full));
    }
    this._createOperationGeometry = null, this.emit("complete", { graphic: e13, ...t9 });
  }
  onCursorUpdate(t9) {
    this._updateGraphic(), this.emit("cursor-update", t9);
  }
  onDeactivate() {
    const { drawOperation: t9 } = this;
    t9 && (t9.isCompleted || t9.cancel());
  }
  onOutlineChanged(t9) {
    return e();
  }
  onCursorEdgeChanged(t9) {
    return e();
  }
  onVertexAdd(t9) {
    var _a;
    U2(this._tooltipsContext), this._updateGraphic(), this.elevationLockOnVertexAddDisabled || I3((_a = t9.vertices.at(0)) == null ? void 0 : _a.coordinates, this._tooltipsContext), this.emit("vertex-add", t9);
  }
  onVertexRemove(t9) {
    U2(this._tooltipsContext), this._updateGraphic(), this.emit("vertex-remove", t9);
  }
  onVertexUpdate(t9) {
    this._updateGraphic(), this.emit("vertex-update", t9);
  }
  _updateGraphic() {
    const t9 = this._getCreateOperationGeometry();
    this._createOperationGeometry = t9, null != t9 ? (null != t9.cursorEdge ? this.addHandles(this.onCursorEdgeChanged(t9.cursorEdge), F6.activeEdge) : this.removeHandles(F6.activeEdge), null != t9.outline ? this.addHandles(this.onOutlineChanged(t9.outline), F6.outline) : this.removeHandles(F6.outline), null != t9.committedVertices ? this.addHandles(this.onRegularVerticesChanged(t9.committedVertices), F6.regularVertices) : this.removeHandles(F6.regularVertices), null != t9.cursorVertex ? this.addHandles(this.onActiveVertexChanged(t9.cursorVertex), F6.activeVertex) : this.removeHandles(F6.activeVertex), null != t9.full ? this._createOrUpdateGraphic(t9.full) : this.removeHandles(A5)) : this._destroyAllVisualizations();
  }
  get activeTooltipInfo() {
    var _a;
    return ((_a = this._coordinateFormatterLoadTask) == null ? void 0 : _a.finished) ? V5(this._tooltipsContext) : null;
  }
};
r([m()], I4.prototype, "_coordinateFormatterLoadTask", void 0), r([m()], I4.prototype, "_createOperationGeometry", void 0), r([m()], I4.prototype, "_tooltipsContext", null), r([m({ value: true })], I4.prototype, "centered", null), r([m()], I4.prototype, "cursor", null), r([m({ nonNullable: true })], I4.prototype, "defaultZ", void 0), r([m({ constructOnly: true })], I4.prototype, "directionOptions", void 0), r([m()], I4.prototype, "drawOperation", void 0), r([m()], I4.prototype, "elevationLockOnVertexAddDisabled", void 0), r([m({ value: true })], I4.prototype, "enabled", null), r([m({ value: true })], I4.prototype, "forceUniformSize", null), r([m({ constructOnly: true })], I4.prototype, "geometryType", void 0), r([m()], I4.prototype, "graphic", null), r([m({ constructOnly: true })], I4.prototype, "graphicProperties", void 0), r([m()], I4.prototype, "graphicSymbol", null), r([m({ constructOnly: true })], I4.prototype, "hasZ", void 0), r([m({ constructOnly: true })], I4.prototype, "geometryToPlace", void 0), r([m()], I4.prototype, "mode", null), r([m()], I4.prototype, "snappingManager", void 0), r([m()], I4.prototype, "snapToScene", void 0), r([m()], I4.prototype, "tooltip", void 0), r([m()], I4.prototype, "tooltipInfos", void 0), r([m({ constructOnly: true, type: l5 })], I4.prototype, "sketchOptions", void 0), r([m()], I4.prototype, "updating", null), r([m({ constructOnly: true, nonNullable: true })], I4.prototype, "view", void 0), r([m({ constructOnly: true })], I4.prototype, "undoRedo", null), r([m()], I4.prototype, "activeTooltipInfo", null), I4 = r([a2("esri.views.draw.DrawGraphicTool")], I4);
var A5 = Symbol("create-operation-graphic");
var F6 = { outline: Symbol("outline-visual"), regularVertices: Symbol("regular-vertices-visual"), activeVertex: Symbol("active-vertex-visual"), activeEdge: Symbol("active-edge-visual") };
function M4(t9) {
  switch (t9) {
    case "point":
    case "polyline":
    case "polygon":
    case "multipoint":
      return t9;
    case "circle":
    case "rectangle":
      return "segment";
    case "mesh":
      return "point";
  }
}
var Z3 = 48;

// node_modules/@arcgis/core/views/interactive/dragEventPipeline.js
function i9(t9, n8) {
  let e13 = null, r9 = null;
  return (a11) => {
    if ("cancel" === a11.action) return void (null != r9 && (r9.execute({ action: "cancel" }), e13 = null, r9 = null));
    const o7 = { action: a11.action, screenStart: a11.start, screenEnd: a11.screenPoint };
    "start" === a11.action && null == e13 && (e13 = new w7(), r9 = new w7(), n8(t9, e13, r9, a11.pointerType, o7)), null != e13 && e13.execute(o7), "end" === a11.action && null != e13 && (e13 = null, r9 = null);
  };
}
function p5(t9, n8) {
  return t9.events.on("drag", i9(t9, n8));
}
function m5(t9, n8) {
  const e13 = [t9.x, t9.y, t9.z ?? 0], r9 = n8, a11 = [Math.cos(r9), Math.sin(r9)], o7 = Math.sqrt(a11[0] * a11[0] + a11[1] * a11[1]);
  if (0 === o7) return null;
  a11[0] /= o7, a11[1] /= o7;
  const l9 = (t10) => {
    const n9 = (t10.x - e13[0]) * a11[0] + (t10.y - e13[1]) * a11[1];
    t10.x = e13[0] + n9 * a11[0], t10.y = e13[1] + n9 * a11[1];
  };
  return (t10) => (l9(t10.mapStart), l9(t10.mapEnd), { ...t10, axis: a11 });
}
function f6(t9) {
  let n8 = null;
  return (e13) => {
    if ("start" === e13.action && (n8 = y4(t9, e13.mapStart.spatialReference)), null == n8) return null;
    const r9 = e13.mapEnd.x - e13.mapStart.x, a11 = e13.mapEnd.y - e13.mapStart.y, o7 = (e13.mapEnd.z ?? 0) - (e13.mapStart.z ?? 0);
    return n8.move(r9, a11, o7, e13.action), { ...e13, translationX: r9, translationY: a11, translationZ: o7 };
  };
}
function d7(t9, n8) {
  return null == t9 ? null : t9.spatialReference.equals(n8) ? t9.clone() : O(t9, n8);
}
function y4(t9, n8) {
  const e13 = t9.operations;
  if (!e13) return null;
  const r9 = e13.data.geometry, c12 = k3(n8);
  if (r9.spatialReference.equals(c12)) return x4(t9, e13, () => {
  });
  if ("mesh" !== r9.type) {
    const n9 = d7(r9, c12);
    if (null == n9) return null;
    const o7 = r9.spatialReference;
    return x4(t9, E3.fromGeometry(n9, e13.viewingMode), () => {
      const t10 = O(r9, o7);
      e13.trySetGeometry(t10);
    });
  }
  if (c3(r9)) {
    const n9 = d7(r9.origin, c12);
    if (!n9) return null;
    const o7 = r9.spatialReference, l9 = E3.fromGeometry(n9, e13.viewingMode);
    return x4(t9, e13, () => {
      const t10 = O(l9.data.geometry, o7), n10 = t10.x - r9.origin.x, c13 = t10.y - r9.origin.y, s4 = (t10.z ?? 0) - (r9.origin.z ?? 0);
      e13.move(n10, c13, s4);
    });
  }
  return null;
}
function x4(t9, n8, e13) {
  let r9 = 0, a11 = 0, o7 = 0;
  return { move: (l9, c12, s4, u10) => {
    var _a;
    "start" === u10 && (r9 = 0, a11 = 0, o7 = 0);
    const i10 = l9 - r9, p7 = c12 - a11, m7 = s4 - o7;
    n8.move(i10, p7, m7), r9 += i10, a11 += p7, o7 += m7, e13(), "end" === u10 && ((_a = t9.endInteraction) == null ? void 0 : _a.call(t9));
  } };
}
function E6(t9, n8 = null, e13) {
  var _a;
  let r9 = null;
  const o7 = null == n8 || ((_a = t9.spatialReference) == null ? void 0 : _a.equals(n8)) ? (t10) => t10 : (t10) => null != t10 ? O(t10, n8) : t10, l9 = { exclude: [], ...e13 };
  return (n9) => {
    if ("start" === n9.action && (r9 = o7(t9.toMap(n9.screenStart, l9))), null == r9) return null;
    const e14 = o7(t9.toMap(n9.screenEnd, l9));
    return null != e14 ? { ...n9, mapStart: r9, mapEnd: e14 } : null;
  };
}
function S3(n8) {
  const e13 = n8.map((t9) => f6(t9)).filter(G);
  return (t9) => {
    const n9 = t9.mapEnd.x - t9.mapStart.x, r9 = t9.mapEnd.y - t9.mapStart.y, a11 = t9.mapEnd.z - t9.mapStart.z;
    return e13.forEach((n10) => n10(t9)), { ...t9, translationX: n9, translationY: r9, translationZ: a11 };
  };
}
function g8(t9) {
  var _a;
  const n8 = (_a = t9.operations) == null ? void 0 : _a.createResetState();
  return (t10) => (n8 == null ? void 0 : n8.remove(), t10);
}
function z5(t9) {
  const n8 = t9.map((t10) => g8(t10)).filter((t10) => null != t10);
  return (t10) => (n8.forEach((n9) => n9(t10)), t10);
}
function v3() {
  let t9 = 0, n8 = 0, e13 = 0;
  return (r9) => {
    "start" === r9.action && (t9 = r9.mapStart.x, n8 = r9.mapStart.y, e13 = r9.mapStart.z);
    const a11 = r9.mapEnd.x - t9, o7 = r9.mapEnd.y - n8, l9 = r9.mapEnd.z - e13;
    return t9 = r9.mapEnd.x, n8 = r9.mapEnd.y, e13 = r9.mapEnd.z, { ...r9, mapDeltaX: a11, mapDeltaY: o7, mapDeltaZ: l9, mapDeltaSpatialReference: r9.mapStart.spatialReference };
  };
}
function j11() {
  let t9 = 0, n8 = 0;
  return (e13) => {
    "start" === e13.action && (t9 = e13.screenStart.x, n8 = e13.screenStart.y);
    const r9 = e13.screenEnd.x - t9, a11 = e13.screenEnd.y - n8;
    return t9 = e13.screenEnd.x, n8 = e13.screenEnd.y, { ...e13, screenDeltaX: r9, screenDeltaY: a11 };
  };
}
function M5(t9, n8) {
  let a11 = null, o7 = 0, l9 = 0;
  return (c12) => {
    var _a;
    if ("start" === c12.action && (a11 = (_a = t9.toScreen) == null ? void 0 : _a.call(t9, n8), null != a11 && (a11.x < 0 || a11.x > t9.width || a11.y < 0 || a11.y > t9.height ? a11 = null : (o7 = c12.screenStart.x - a11.x, l9 = c12.screenStart.y - a11.y))), null == a11) return null;
    const s4 = r2(c12.screenEnd.x - o7, 0, t9.width), u10 = r2(c12.screenEnd.y - l9, 0, t9.height), i10 = c(s4, u10);
    return c12.screenStart = a11, c12.screenEnd = i10, c12;
  };
}
var R9 = () => {
};
var w7 = class _w {
  constructor() {
    this.execute = R9;
  }
  next(t9, n8 = new _w()) {
    return null != t9 && (this.execute = (e13) => {
      const r9 = t9(e13);
      null != r9 && n8.execute(r9);
    }), n8;
  }
};
function D3(t9, n8, e13 = []) {
  if ("2d" === t9.type) return (t10) => t10;
  let r9 = null;
  return (a11) => {
    "start" === a11.action && (r9 = t9.toMap(a11.screenStart, { exclude: e13 }), null != r9 && (r9.z = p(r9, t9, n8)));
    const o7 = t9.toMap(a11.screenEnd, { exclude: e13 });
    null != o7 && (o7.z = p(o7, t9, n8));
    const l9 = null != r9 && null != o7 ? { sceneStart: r9, sceneEnd: o7 } : null;
    return { ...a11, scenePoints: l9 };
  };
}
function G4(t9, n8, e13) {
  const r9 = n8.elevationProvider.getElevation(t9.x, t9.y, t9.z ?? 0, t9.spatialReference, "scene") ?? 0, a11 = x2(t9);
  return a11.z = r9, a11.hasZ = true, a11.z = p(a11, n8, e13), a11;
}
function U3(t9, n8) {
  if ("2d" === t9.type) return (t10) => t10;
  let e13 = null;
  return (r9) => {
    "start" === r9.action && (e13 = G4(r9.mapStart, t9, n8));
    const a11 = G4(r9.mapEnd, t9, n8), o7 = null != e13 && null != a11 ? { sceneStart: e13, sceneEnd: a11 } : null;
    return { ...r9, scenePoints: o7 };
  };
}

// node_modules/@arcgis/core/views/interactive/snapping/SnappingDragPipelineStep.js
function f7({ predicate: o7 = () => true, snappingManager: i10, snappingContext: l9, updatingHandles: u10, useZ: c12 = true }) {
  const p7 = new w7();
  if (null == i10) return { snappingStep: [y5, p7], cancelSnapping: y5 };
  let f8, Z4 = null, j12 = null, z7 = null;
  const T6 = () => {
    Z4 = e2(Z4), i10.doneSnapping(), j12 == null ? void 0 : j12.frameTask.remove(), j12 = null, f8 = l(f8), z7 = null;
  }, k6 = d8(i10, c12, p7);
  let w8 = null, I5 = null, U5 = null;
  return { snappingStep: [(n8) => {
    if (!o7(n8)) return n8;
    const { action: e13 } = n8;
    if ("start" === e13) {
      const { info: e14 } = n8, t9 = m6(i10.view);
      if (j12 = g9(l9, n8, t9), j12.context.selfSnappingZ = null, !c12 && null != e14) {
        const n9 = S4(l9.coordinateHelper, e14.handle.component);
        null != n9 && (j12.context.selfSnappingZ = { value: n9, elevationInfo: l9.elevationInfo ?? j5 });
      }
    }
    if (null != j12) {
      const { context: o8, originalScenePos: l10, originalPos: a11 } = j12, { mapEnd: s4, mapStart: p8, scenePoints: d9 } = n8, m7 = x5(a11, v4(s4, p8)), g10 = v4(p8, a11), S6 = { ...n8, action: "update" }, y6 = j12.context, T7 = P7(l10, d9), C4 = i10.update({ point: m7, scenePoint: T7, context: o8 });
      if (U5 = C4, h6(s4, C4, g10, c12), w8 = m7, I5 = T7, "end" !== e13) {
        const { frameTask: n9 } = j12;
        null == Z4 && (Z4 = new AbortController()), z7 = (e14) => {
          u10.addPromise(d(k6({ frameTask: n9, event: S6, context: y6, point: m7, scenePoint: T7, delta: g10, getLastState: () => ({ point: w8, scenePoint: I5, updatePoint: e14.forceUpdate ? null : U5 }) }, Z4.signal)));
        }, z7({ forceUpdate: false }), null == f8 && (f8 = d3(() => i10.options.effectiveEnabled, () => z7 == null ? void 0 : z7({ forceUpdate: true })));
      }
    }
    return "end" === e13 && T6(), n8;
  }, p7], cancelSnapping: (n8) => (T6(), n8) };
}
function d8(n8, e13, t9) {
  return k(async ({ frameTask: o7, point: r9, scenePoint: l9, context: a11, event: s4, delta: u10, getLastState: c12 }, p7) => {
    const f8 = await o7.schedule(() => n8.snap({ point: r9, scenePoint: l9, context: a11, signal: p7 }), p7);
    if (f8.valid) {
      let l10 = await o7.schedule(() => f8.apply(), p7);
      const d9 = c12();
      null != d9.point && r9 !== d9.point && (l10 = n8.update({ point: d9.point, scenePoint: d9.scenePoint, context: a11 })), null != d9.updatePoint && a5(l10, d9.updatePoint) || (h6(s4.mapEnd, l10, u10, e13), t9.execute(s4));
    }
  });
}
function m6(n8) {
  return "3d" === n8.type ? n8.resourceController.scheduler.registerTask(g4.SNAPPING) : F;
}
function g9(n8, e13, t9) {
  return { context: new e8({ editGeometryOperations: n8.editGeometryOperations, elevationInfo: n8.elevationInfo, pointer: n8.pointer, vertexHandle: null != e13.info ? e13.info.handle : null, excludeFeature: n8.excludeFeature, feature: n8.feature, visualizer: n8.visualizer }), originalPos: null != e13.snapOrigin ? n8.coordinateHelper.vectorToDehydratedPoint(e13.snapOrigin) : e13.mapStart, originalScenePos: null != e13.scenePoints ? e13.scenePoints.sceneStart : null, frameTask: t9 };
}
function x5(n8, [e13, t9, o7]) {
  const r9 = x2(n8);
  return r9.x += e13, r9.y += t9, r9.hasZ && (r9.z += o7), r9;
}
function P7(n8, e13) {
  return null == n8 || null == e13 ? null : x5(n8, v4(e13.sceneEnd, e13.sceneStart));
}
function v4(n8, e13) {
  const t9 = n8.hasZ && e13.hasZ ? n8.z - e13.z : 0;
  return [n8.x - e13.x, n8.y - e13.y, t9];
}
function h6(n8, e13, [t9, o7, r9], i10) {
  n8.x = e13.x + t9, n8.y = e13.y + o7, i10 && n8.hasZ && e13.hasZ && (n8.z = e13.z + r9);
}
function S4(n8, e13) {
  if (!n8.hasZ()) return null;
  const t9 = e13.vertices;
  let o7 = null;
  for (const r9 of t9) {
    const e14 = n8.getZ(r9.pos);
    if (null != o7 && null != e14 && Math.abs(e14 - o7) > 1e-6) return null;
    null == o7 && (o7 = e14);
  }
  return o7;
}
function y5(n8) {
  return n8;
}

// node_modules/@arcgis/core/views/draw/DrawingMode.js
var e12 = "click";

// node_modules/@arcgis/core/views/draw/DrawManipulator.js
var t8 = class {
  constructor({ consumesClicks: t9, grabbableForEvent: s4 }) {
    this.events = new i2(), this.interactive = true, this.selectable = false, this.cursor = null, this.grabbable = true, this.consumesClicks = t9, this.grabbableForEvent = s4;
  }
  destroy() {
  }
  intersectionDistance(e13, t9) {
    return 0;
  }
  attach() {
  }
  detach() {
  }
  onElevationChange() {
  }
  onViewChange() {
  }
};

// node_modules/@arcgis/core/views/interactive/snapping/SnappingOperation.js
var p6 = class extends g {
  constructor(t9) {
    super(t9), this.constrainResult = (t10) => t10, this._snapPoints = null, this._frameTask = null, this._abortController = null, this._stagedPoint = null, this._snap = k(async (t10, s4, o7, n8) => {
      const i10 = this._frameTask;
      if (null == i10) return;
      const r9 = await i10.schedule(() => s4.snap({ ...t10, context: o7, signal: n8 }), n8);
      r9.valid && await i10.schedule(() => {
        this.stagedPoint = r9.apply(), t10 !== this._snapPoints && null != this._snapPoints && (this.stagedPoint = s4.update({ ...this._snapPoints, context: o7 }));
      }, n8);
    });
  }
  get stagedPoint() {
    return this._stagedPoint;
  }
  set stagedPoint(t9) {
    this._stagedPoint = this.constrainResult(t9);
  }
  initialize() {
    var _a, _b;
    const t9 = "3d" === this.view.type ? (_b = (_a = this.view) == null ? void 0 : _a.resourceController) == null ? void 0 : _b.scheduler : null;
    this._frameTask = null != t9 ? t9.registerTask(g4.SNAPPING) : F;
  }
  destroy() {
    this._abortController = e2(this._abortController), this._frameTask = l(this._frameTask);
  }
  update(t9, s4, o7) {
    this._snapPoints = t9;
    const { point: n8, scenePoint: i10 } = t9, r9 = s4.update({ point: n8, scenePoint: i10, context: o7 });
    return this.stagedPoint = r9, r9;
  }
  async snap(t9, s4, o7) {
    const { point: n8, scenePoint: i10 } = t9;
    return this.stagedPoint = s4.update({ point: n8, scenePoint: i10, context: o7 }), this._snapPoints = t9, null == this._abortController && (this._abortController = new AbortController()), this._snap(t9, s4, o7, this._abortController.signal);
  }
  async snapAgainNearPreviousMapPoint(t9, s4) {
    null != this._snapPoints && await this.snap(this._snapPoints, t9, s4);
  }
  abort() {
    this._abortController = e2(this._abortController), this._snapPoints = null;
  }
};
r([m({ constructOnly: true })], p6.prototype, "view", void 0), r([m()], p6.prototype, "stagedPoint", null), r([m()], p6.prototype, "constrainResult", void 0), r([m()], p6.prototype, "_stagedPoint", void 0), p6 = r([a2("esri.views.interactive.snapping.SnappingOperation")], p6);

// node_modules/@arcgis/core/views/draw/DrawOperation.js
var A6 = "crosshair";
var L5 = "progress";
var U4 = Symbol();
var z6 = Symbol();
var F7 = class extends i2.EventedMixin(g) {
  constructor(t9) {
    super(t9), this._createOperationCompleted = false, this._hideDefaultCursor = false, this._pointerDownStates = new t2(), this._stagedScreenPoint = null, this._stagedPointerType = null, this._updatingHandles = new h2(), this._stagedPointerId = null, this.constraintsEnabled = false, this.constraints = void 0, this._getPointConstraint = t3(V4), this._getPolylineOrPolygonConstraint = t3(k5), this.constraintZ = null, this.defaultZ = null, this.isDraped = true, this.labelOptions = new c6(), this.cursor = null, this.loading = false, this.snapToSceneEnabled = null, this.firstVertex = null, this.lastVertex = null, this.secondToLastVertex = null, null == t9.elevationInfo && (this.elevationInfo = u5(!!t9.hasZ));
  }
  initialize() {
    const { geometryType: t9, view: e13 } = this, i10 = e13.spatialReference, n8 = "viewingMode" in e13.state ? e13.state.viewingMode : l3.Local, o7 = "segment" === t9 || "multipoint" === t9 ? "polyline" : t9;
    this.coordinateHelper = P3(this.hasZ, this.hasM, i10), this._editGeometryOperations = new E3(new p2(o7, this.coordinateHelper), n8), this._snappingOperation = new p6({ view: e13 }), this.addHandles([d3(() => ({ stagedPoint: this._snappingOperation.stagedPoint, constraint: this._constraint }), ({ stagedPoint: t10, constraint: e14 }, i11) => {
      const { snappingOptions: n9 } = this;
      n9 && (n9.forceDisabled = null != e14 && Le(e14));
      if (null != i11 && t10 === i11.stagedPoint && e14 !== i11.constraint) return this._onKeyboardBasedChange();
      this._processCursor(t10 ?? this._screenToMap(this._stagedScreenPoint));
    }, { equals: (t10, e14) => t10.stagedPoint === e14.stagedPoint && o(t10.constraint, e14.constraint) }), d3(() => this.view.viewpoint, (t10, e14) => {
      t10 && e14 && y(t10, e14) && this._onKeyboardBasedChange();
    })]), this._activeComponent = new a7(i10, n8), this._editGeometryOperations.data.components.push(this._activeComponent);
    const s4 = this.segmentLabels;
    null != s4 && (s4.context = { view: e13, editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, labelOptions: this.labelOptions }, this.addHandles(d3(() => this.labelOptions.enabled, (t10) => {
      s4.visible = t10;
    }, A))), this.addHandles(this._editGeometryOperations.on(["vertex-add", "vertex-update", "vertex-remove"], (t10) => {
      var _a, _b, _c, _d;
      const e14 = t10.vertices.map((t11) => ({ componentIndex: 0, vertexIndex: t11.index, coordinates: this.coordinateHelper.vectorToArray(t11.pos) })), i11 = e14.map((t11) => t11.coordinates), n9 = this.coordinateHelper.vectorToDehydratedPoint((_a = this._activeComponent.getFirstVertex()) == null ? void 0 : _a.pos) ?? null;
      a5(n9, this.firstVertex) || (this.firstVertex = n9);
      const o8 = this.coordinateHelper.vectorToDehydratedPoint((_b = this._activeComponent.getLastVertex()) == null ? void 0 : _b.pos) ?? null;
      a5(o8, this.lastVertex) || (this.lastVertex = o8);
      const r9 = this.coordinateHelper.vectorToDehydratedPoint((_d = (_c = this._activeComponent.edges.at(-1)) == null ? void 0 : _c.leftVertex) == null ? void 0 : _d.pos) ?? null;
      switch (a5(r9, this.secondToLastVertex) || (this.secondToLastVertex = r9), this._processCursor(this.cursorVertex), t10.type) {
        case "vertex-add":
          this.emit(t10.type, { ...t10, added: i11, vertices: e14 });
          break;
        case "vertex-update":
          this.emit(t10.type, { ...t10, updated: i11, vertices: e14 });
          break;
        case "vertex-remove":
          this.emit(t10.type, { ...t10, removed: i11, vertices: e14 });
      }
    }));
    const p7 = this._manipulator = new t8({ consumesClicks: false, grabbableForEvent: (t10) => "click" !== this.drawingMode || "touch" === t10.pointerType && this._snappingEnabled && 1 === this._pointerDownStates.size });
    this.manipulators.add(p7), p7.grabbable = "point" !== t9 && "multipoint" !== t9, this.addHandles([p7.events.on("immediate-click", (t10) => this._onImmediateClick(t10)), p7.events.on("immediate-double-click", (t10) => this._onImmediateDoubleClick(t10)), d3(() => this.drawingMode, () => {
      this.removeHandles(U4), this.addHandles(this._createManipulatorDragPipeline(p7), U4);
    }, A), d3(() => ({ effectiveCursor: this.effectiveCursor }), ({ effectiveCursor: t10 }) => {
      p7.cursor = t10;
    }, A)]), N3(this, () => {
      const t10 = this.view.inputManager.latestPointerType ?? "mouse", e14 = this._getSnappingContext(t10);
      if (null != this.snappingManager) {
        const t11 = this._snappingOperation.snapAgainNearPreviousMapPoint(this.snappingManager, e14);
        this._updatingHandles.addPromise(d(t11));
      }
    });
  }
  destroy() {
    u(this.segmentLabels), u(this._snappingOperation), this._editGeometryOperations = u(this._editGeometryOperations), this._updatingHandles.destroy();
  }
  get _isDragging() {
    const { _stagedPointerId: t9, _manipulator: e13 } = this;
    return null != t9 && this._pointerDownStates.has(t9) || e13.grabbing || !e13.interactive;
  }
  get _snappingEnabled() {
    return null != this.snappingManager && this.snappingManager.options.effectiveEnabled;
  }
  get _requiresScenePoint() {
    const t9 = this._updateAndGetEffectiveDrawSurface();
    return "3d" === this.view.type && this.drawSurface !== t9;
  }
  get canRedo() {
    return this._editGeometryOperations.canRedo;
  }
  get canUndo() {
    return this._editGeometryOperations.canUndo;
  }
  get committedVertices() {
    return this._activeComponent.vertices.map((t9) => this.coordinateHelper.vectorToArray(t9.pos));
  }
  get _constraint() {
    const { constraints: t9, constraintsEnabled: e13 } = this;
    if (t9 && e13) switch (this.geometryType) {
      case "point":
      case "multipoint":
        return this._getPointConstraint(t9);
      case "polygon":
      case "polyline":
        return this._getPolylineOrPolygonConstraint(this.lastVertex, this.secondToLastVertex, t9);
    }
  }
  set drawingMode(t9) {
    this._set("drawingMode", t9 ?? e12);
  }
  get effectiveCursor() {
    return this.loading ? L5 : this._hideDefaultCursor ? null : this.cursor || A6;
  }
  get interactive() {
    return this._manipulator.interactive;
  }
  set interactive(t9) {
    this._manipulator.interactive = t9;
  }
  get isCompleted() {
    return this._createOperationCompleted;
  }
  get numCommittedVertices() {
    return this._activeComponent.vertices.length;
  }
  get snappingOptions() {
    return null != this.snappingManager ? this.snappingManager.options : null;
  }
  get cursorVertex() {
    return this._get("cursorVertex");
  }
  get visualizationCursorVertex() {
    return "mouse" === this._stagedPointerType ? this.cursorVertex : null;
  }
  get committableVertex() {
    const { cursorVertex: t9, lastVertex: e13, firstVertex: i10, geometryType: n8 } = this;
    return "polygon" === n8 && i3(t9, i10) || i3(t9, e13) ? null : t9;
  }
  get updating() {
    return this._updatingHandles.updating;
  }
  get geometryIncludingUncommittedVertices() {
    const { committedVertices: t9, committableVertex: e13, coordinateHelper: i10 } = this, n8 = t9.slice();
    return null != e13 && n8.push(i10.pointToArray(e13)), n8;
  }
  cancel() {
    this.complete({ aborted: true });
  }
  commitStagedVertex() {
    this._snappingOperation.abort();
    const { committableVertex: t9 } = this;
    null != t9 && this._editGeometryOperations.appendVertex(this.coordinateHelper.pointToVector(t9));
  }
  complete(t9) {
    var _a;
    const e13 = (t9 == null ? void 0 : t9.aborted) || false;
    this._snappingOperation.abort(), (_a = this.snappingManager) == null ? void 0 : _a.doneSnapping();
    const { geometryType: i10, numCommittedVertices: n8 } = this, o7 = "multipoint" === i10 && 0 === n8 || "polyline" === i10 && n8 < 2 || "polygon" === i10 && n8 < 3;
    "segment" !== i10 && "point" !== i10 || this.commitStagedVertex(), this._createOperationCompleted = !o7, (this.isCompleted || e13) && (this._stagedScreenPoint = null, this._stagedPointerId = null, this._stagedPointerType = null, this._processCursor(null), this.emit("complete", { vertices: this.committedVertices.map((t10, e14) => ({ componentIndex: 0, vertexIndex: e14, coordinates: t10 })), aborted: e13, type: "complete" }));
  }
  onInputEvent(t9) {
    switch (t9.type) {
      case "pointer-down":
        this._pointerDownStates.add(t9.pointerId);
        break;
      case "pointer-up":
        this._pointerDownStates.delete(t9.pointerId);
    }
    switch (t9.type) {
      case "pointer-move":
        return this._onPointerMove(t9);
      case "hold":
        return this._onHold(t9);
    }
  }
  redo() {
    this._editGeometryOperations.redo();
  }
  undo() {
    null != this.snappingManager && this.snappingManager.doneSnapping(), this._editGeometryOperations.undo();
  }
  _processCursor(t9) {
    var _a, _b;
    const e13 = a(this.cursorVertex), i10 = a(t9), o7 = i10 && (((_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.constrainZ(i10)) ?? i10), r9 = this._snapToClosingVertex(o7), s4 = this._applyConstraints(r9);
    i3(e13, s4) || (this._set("cursorVertex", s4), (_b = this.segmentLabels) == null ? void 0 : _b.set("stagedVertex", null != s4 ? this.coordinateHelper.pointToVector(s4) : null), null == s4 || "mouse" !== this._stagedPointerType ? this.emit("cursor-remove") : this.emit("cursor-update", { updated: null, vertices: [{ componentIndex: 0, vertexIndex: this._activeComponent.vertices.length, coordinates: this.coordinateHelper.pointToArray(s4) }], operation: "apply", type: "vertex-update" }));
  }
  _snapToClosingVertex(t9) {
    if (null == t9 || this._isDragging || "polygon" !== this.geometryType || this.numCommittedVertices <= 2) return t9;
    const e13 = this._mapToScreen(t9);
    if (!e13) return t9;
    const i10 = this._activeComponent;
    return this._vertexWithinPointerDistance(i10.vertices[0].pos, e13) ? this.firstVertex : this._vertexWithinPointerDistance(i10.vertices.at(-1).pos, e13) ? this.lastVertex : t9;
  }
  _createManipulatorDragPipeline(t9) {
    switch (this.drawingMode) {
      case "click":
        return this._createManipulatorDragPipelineClick(t9);
      case "freehand":
        return this._createManipulatorDragPipelineFreehand(t9);
      case "hybrid":
        return this._createManipulatorDragPipelineHybrid(t9);
    }
  }
  _createManipulatorDragPipelineClick(t9) {
    return p5(t9, (t10, e13, i10, n8) => {
      const o7 = "touch" === n8 && this._snappingEnabled;
      if (this.isCompleted || !o7) return;
      const { snappingStep: r9, cancelSnapping: s4 } = f7({ predicate: () => o7, snappingManager: this.snappingManager, snappingContext: new e8({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, feature: this.graphic, pointer: n8, visualizer: this.snappingVisualizer, drawConstraints: this.constraints }), updatingHandles: this._updatingHandles, useZ: !this._requiresScenePoint });
      i10 = i10.next((t11) => (o7 && null != this.snappingManager && this.snappingManager.doneSnapping(), t11)).next(s4), e13.next(this._screenToMapDragEventStep()).next((t11) => ("start" === t11.action && (this._processCursor(t11.mapStart), ("segment" === this.geometryType || o7 && !this.numCommittedVertices) && this.commitStagedVertex()), t11)).next(D3(this.view, this.elevationInfo)).next(...r9).next((t11) => (o7 && (this._processCursor(t11.mapEnd), "end" === t11.action && this.commitStagedVertex()), t11)).next((t11) => ("end" === t11.action && ("mouse" !== this._stagedPointerType && this._snappingOperation.abort(), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete()), t11));
    });
  }
  _createManipulatorDragPipelineFreehand(t9) {
    return p5(t9, (t10, e13) => {
      this.isCompleted || e13.next(this._screenToMapDragEventStep()).next((t11) => ("start" === t11.action && (this._snappingOperation.abort(), null == this.committableVertex && this._processCursor(t11.mapStart), "segment" === this.geometryType && this.commitStagedVertex()), t11)).next((t11) => {
        switch (t11.action) {
          case "start":
          case "update":
            this._processCursor(t11.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            this.complete();
        }
        return t11;
      });
    });
  }
  _createManipulatorDragPipelineHybrid(t9) {
    return p5(t9, (t10, e13) => {
      this.isCompleted || e13.next(this._screenToMapDragEventStep()).next((t11) => ("start" === t11.action && (this._snappingOperation.abort(), this.addHandles(this._editGeometryOperations.createUndoGroup(), z6), this._processCursor(t11.mapStart), this.commitStagedVertex()), t11)).next((t11) => {
        switch (t11.action) {
          case "start":
          case "update":
            this._processCursor(t11.mapEnd), "polygon" !== this.geometryType && "polyline" !== this.geometryType || this.commitStagedVertex();
            break;
          case "end":
            "mouse" !== this._stagedPointerType && this._snappingOperation.abort(), this.removeHandles(z6), "segment" !== this.geometryType && "point" !== this.geometryType || this.complete();
        }
        return t11;
      });
    });
  }
  get _drawAtFixedElevation() {
    const { constraintsEnabled: t9, constraintZ: e13, geometryType: i10, numCommittedVertices: n8 } = this;
    return t9 ? null != e13 || "segment" === i10 && n8 > 0 : ("segment" === i10 || "polygon" === i10) && n8 > 0;
  }
  _updateAndGetEffectiveDrawSurface() {
    var _a;
    const { constraintsEnabled: t9, coordinateHelper: e13, drawSurface: i10, elevationDrawSurface: n8, snapToSceneEnabled: o7 } = this;
    if (null == n8) return i10;
    if (!this.hasZ) return n8.defaultZ = null, n8;
    const r9 = (_a = this.elevationInfo) == null ? void 0 : _a.mode;
    let s4 = this.defaultZ, a11 = t9 || "absolute-height" === r9;
    if (null != o7 && (a11 = o7), "on-the-ground" === r9 && (a11 = false), this._drawAtFixedElevation) {
      s4 = (t9 ? this.constraintZ : null) ?? e13.getZ(this._activeComponent.vertices[0].pos), a11 = false;
    }
    return a11 ? i10 : (n8.defaultZ = s4, n8);
  }
  _mapToScreen(t9) {
    var _a;
    return (_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.mapToScreen(t9);
  }
  _onHold(t9) {
    this._snappingOperation.abort(), "click" === this.drawingMode && "touch" === t9.pointerType && this._snappingEnabled && this._processCursor(t9.mapPoint), t9.stopPropagation();
  }
  _onImmediateClick(t9) {
    if (!("mouse" === t9.pointerType && 2 === t9.button || this._manipulator.dragging)) try {
      const { drawingMode: e13, geometryType: i10 } = this;
      this._stagedPointerType = t9.pointerType, this._stagedScreenPoint = t9.screenPoint;
      const n8 = this._screenToMap(t9.screenPoint);
      if (null == n8) return;
      if (null == n8 || "freehand" === e13 && "point" !== i10 && "multipoint" !== i10) return;
      if (this._snappingEnabled && null != this.cursorVertex || this._processCursor(n8), null == this.committableVertex) return void this.complete();
      this.commitStagedVertex(), "mouse" !== t9.pointerType && this._processCursor(null), ("freehand" === e13 && "multipoint" !== this.geometryType || "point" === i10 || "segment" === i10 && 2 === this.numCommittedVertices || "segment" === i10 && "hybrid" === e13 && 1 === this.numCommittedVertices) && this.complete();
    } finally {
      t9.stopPropagation();
    }
  }
  _onImmediateDoubleClick(t9) {
    this._manipulator.dragging || "point" === this.geometryType || (this.complete(), t9.stopPropagation());
  }
  _onPointerMove(t9) {
    const e13 = c(t9.x, t9.y);
    this._stagedScreenPoint = e13, this._stagedPointerType = t9.pointerType, this._stagedPointerId = t9.pointerId, this._isDragging ? this._snappingOperation.abort() : (t9.stopPropagation(), this._processCursorMovementRelativeToSurface(e13, t9.pointerType));
  }
  _onKeyboardBasedChange() {
    "mouse" === this._stagedPointerType && this._stagedScreenPoint && null != this._stagedPointerId && !this._isDragging ? this._processCursorMovementRelativeToSurface(this._stagedScreenPoint, this._stagedPointerType) : this._snappingOperation.abort();
  }
  _processCursorMovementRelativeToSurface(t9, e13) {
    var _a;
    const i10 = this._snappingOperation, n8 = this._screenToMap(t9), o7 = this._requiresScenePoint ? (_a = this.drawSurface) == null ? void 0 : _a.screenToMap(t9) : null;
    if (null == n8) return this._hideDefaultCursor = true, this._processCursor(null), void i10.abort();
    this._hideDefaultCursor = false;
    const r9 = this.snappingManager;
    if (null == r9) return this._processCursor(n8), void i10.abort();
    const s4 = this._getSnappingContext(e13);
    this._updatingHandles.addPromise(d(i10.snap({ point: n8, scenePoint: o7 }, r9, s4)));
  }
  _applyConstraints(t9) {
    const { _constraint: e13, constraints: i10 } = this;
    if (!t9 || !i10 || !e13) return t9;
    const { context: n8 } = i10, o7 = G2(t9, n8), r9 = o7 ? e13.closestTo(o7) : void 0;
    if (!r9) return t9;
    const s4 = W3(r9, t9, n8), a11 = "2d" === this.view.type || "absolute-height" !== n8.elevationInfo.mode;
    return null != s4 && a11 && null != this.constraintZ && this.hasZ && (s4.z = this.constraintZ), s4;
  }
  _screenToMap(t9) {
    var _a;
    return t9 ? (_a = this._updateAndGetEffectiveDrawSurface()) == null ? void 0 : _a.screenToMap(t9) : null;
  }
  _screenToMapDragEventStep() {
    let t9 = null;
    return (e13) => {
      if ("start" === e13.action && (t9 = this._screenToMap(e13.screenStart)), null == t9) return null;
      const i10 = this._screenToMap(e13.screenEnd);
      return null != i10 ? { ...e13, mapStart: t9, mapEnd: i10 } : null;
    };
  }
  _vertexWithinPointerDistance(t9, e13) {
    const i10 = 25, n8 = this._mapToScreen(this.coordinateHelper.vectorToDehydratedPoint(t9));
    return null != n8 && R10(n8, e13, i10);
  }
  _getSnappingContext(t9) {
    var _a;
    const e13 = this._drawAtFixedElevation ? (_a = this.elevationDrawSurface) == null ? void 0 : _a.defaultZ : null;
    return new e8({ editGeometryOperations: this._editGeometryOperations, elevationInfo: this.elevationInfo, pointer: t9, feature: this.graphic, visualizer: this.snappingVisualizer, selfSnappingZ: null != e13 ? { value: e13, elevationInfo: this.elevationInfo } : null, drawConstraints: this.constraints });
  }
};
function R10(t9, e13, i10) {
  const n8 = t9.x - e13.x, o7 = t9.y - e13.y;
  return n8 * n8 + o7 * o7 <= i10;
}
r([m()], F7.prototype, "_hideDefaultCursor", void 0), r([m()], F7.prototype, "_stagedPointerId", void 0), r([m()], F7.prototype, "_isDragging", null), r([m()], F7.prototype, "_snappingOperation", void 0), r([m()], F7.prototype, "_snappingEnabled", null), r([m({ constructOnly: true })], F7.prototype, "graphic", void 0), r([m()], F7.prototype, "constraintsEnabled", void 0), r([m()], F7.prototype, "constraints", void 0), r([m()], F7.prototype, "_constraint", null), r([m()], F7.prototype, "constraintZ", void 0), r([m()], F7.prototype, "defaultZ", void 0), r([m()], F7.prototype, "isDraped", void 0), r([m({ value: e12 })], F7.prototype, "drawingMode", null), r([m({ constructOnly: true })], F7.prototype, "elevationDrawSurface", void 0), r([m({ constructOnly: true })], F7.prototype, "elevationInfo", void 0), r([m({ constructOnly: true, type: c6 })], F7.prototype, "labelOptions", void 0), r([m({ constructOnly: true })], F7.prototype, "geometryType", void 0), r([m({ constructOnly: true })], F7.prototype, "hasM", void 0), r([m({ constructOnly: true })], F7.prototype, "hasZ", void 0), r([m()], F7.prototype, "cursor", void 0), r([m()], F7.prototype, "effectiveCursor", null), r([m()], F7.prototype, "loading", void 0), r([m({ constructOnly: true })], F7.prototype, "manipulators", void 0), r([m({ constructOnly: true })], F7.prototype, "drawSurface", void 0), r([m({ constructOnly: true })], F7.prototype, "segmentLabels", void 0), r([m({ constructOnly: true })], F7.prototype, "snappingManager", void 0), r([m({ constructOnly: true })], F7.prototype, "snappingVisualizer", void 0), r([m()], F7.prototype, "snapToSceneEnabled", void 0), r([m({ readOnly: true })], F7.prototype, "cursorVertex", null), r([m({ readOnly: true })], F7.prototype, "visualizationCursorVertex", null), r([m()], F7.prototype, "committableVertex", null), r([m()], F7.prototype, "firstVertex", void 0), r([m()], F7.prototype, "lastVertex", void 0), r([m()], F7.prototype, "secondToLastVertex", void 0), r([m()], F7.prototype, "updating", null), r([m({ constructOnly: true })], F7.prototype, "view", void 0), F7 = r([a2("esri.views.draw.DrawOperation")], F7);

// node_modules/@arcgis/core/views/draw/drawSurfaces.js
var c11 = class {
  constructor(e13, t9, s4, r9 = null) {
    this._elevationInfo = e13, this.defaultZ = t9, this._view = s4, this._excludeGraphics = r9;
  }
  screenToMap(t9) {
    const { defaultZ: s4, _view: r9 } = this, n8 = r9.sceneIntersectionHelper.intersectElevationFromScreen(f(t9.x, t9.y), this._elevationInfo, s4 ?? 0, this._excludeGraphics);
    return null == s4 && null != n8 && (n8.z = void 0), n8;
  }
  mapToScreen(e13) {
    const t9 = e5(e13.x, e13.y, m2(this._view, e13, this._elevationInfo), e13.spatialReference);
    return this._view.toScreen(t9);
  }
  constrainZ(e13) {
    const { defaultZ: t9 } = this;
    return null != t9 && e13.z !== t9 && ((e13 = x2(e13)).z = t9), e13;
  }
};
var l8 = class {
  constructor(e13, t9, s4 = []) {
    this.view = e13, this.elevationInfo = t9, this.exclude = s4;
  }
  screenToMap(e13) {
    const t9 = this.view.toMap(e13, { exclude: this.exclude, excludeLabels: true });
    return null != t9 && (t9.z = p(t9, this.view, this.elevationInfo)), t9;
  }
  mapToScreen(e13) {
    let t9 = e13;
    return null != this.elevationInfo && (t9 = e5(e13.x, e13.y, m2(this.view, e13, this.elevationInfo), e13.spatialReference)), this.view.toScreen(t9);
  }
  constrainZ(e13) {
    return e13;
  }
};
var h7 = class {
  constructor(e13, t9 = false, s4 = 0) {
    this.view = e13, this.hasZ = t9, this.defaultZ = s4, this.mapToScreen = (t10) => e13.toScreen(t10), this.screenToMap = t9 ? (t10) => {
      const r9 = e13.toMap(t10);
      return r9.z = s4, r9;
    } : (t10) => e13.toMap(t10);
  }
  constrainZ(e13) {
    const { defaultZ: t9 } = this;
    return this.hasZ && e13.z !== t9 && ((e13 = x2(e13)).z = t9), e13;
  }
};
var u9 = class _u {
  screenToMap(e13) {
    const { x: t9, y: r9 } = e13;
    return new j2({ x: t9, y: r9, spatialReference: _u.spatialReference });
  }
  mapToScreen(e13) {
    return c(e13.x, e13.y);
  }
  constrainZ(e13) {
    return e13;
  }
};
u9.spatialReference = new g2();

// node_modules/@arcgis/core/views/interactive/editGeometry/support/editPlaneUtils.js
function V6(o7, i10) {
  return E7(o7, i10, false);
}
function T5(o7, i10) {
  return E7(o7, i10, true);
}
function E7(o7, i10, r9) {
  if (o7 instanceof t4) {
    if (o7.operation instanceof t5) return h8(o7.operation, i10, r9), true;
    if (o7.operation instanceof e7) return v5(o7.operation, i10, r9), true;
    if (o7.operation instanceof c7) return F8(o7.operation, i10, r9), true;
  }
  return false;
}
function h8(o7, i10, r9 = false) {
  const t9 = r9 ? -1 : 1, s4 = r4(t9 * o7.dx, t9 * o7.dy, t9 * o7.dz);
  u3(i10.origin, i10.origin, s4), K(i10);
}
function v5(o7, i10, r9 = false) {
  const t9 = r9 ? -o7.angle : o7.angle;
  w2(i10.basis1, i10.basis1, _, t9), w2(i10.basis2, i10.basis2, _, t9), K(i10);
}
function F8(i10, r9, t9 = false) {
  const s4 = t9 ? 1 / i10.factor1 : i10.factor1, n8 = t9 ? 1 / i10.factor2 : i10.factor2;
  g3(r9.basis1, r9.basis1, s4), g3(r9.basis2, r9.basis2, n8), k2(r9.origin, r9.origin, i10.origin, i10.axis1, s4), k2(r9.origin, r9.origin, i10.origin, i10.axis2, n8), K(r9);
}
function S5(o7, f8, m7, p7, u10 = false) {
  p7 || (p7 = W());
  const l9 = o3(t.get(), o7[1], -o7[0]), d9 = o3(t.get(), Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), j12 = o3(t.get(), Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY), x6 = t.get(), V7 = f8.allVertices;
  V7.forEach(({ pos: n8 }) => {
    o3(x6, j4(o7, n8), j4(l9, n8)), f2(d9, d9, x6), M2(j12, j12, x6);
  });
  const T6 = 1e-6, E8 = o3(t.get(), j12[0] - d9[0] < T6 ? m7 / 2 : 0, j12[1] - d9[1] < T6 ? m7 / 2 : 0);
  e4(d9, d9, E8), u4(j12, j12, E8);
  const h9 = u10 ? V7.reduce((o8, i10) => o8 + (i10.pos[2] ?? 0), 0) / V7.length : 0;
  return l2(p7.basis1, o7, (j12[0] - d9[0]) / 2), l2(p7.basis2, l9, (j12[1] - d9[1]) / 2), o2(p7.origin, d9[0] * o7[0] + d9[1] * l9[0], d9[0] * o7[1] + d9[1] * l9[1], h9), u3(p7.origin, p7.origin, p7.basis1), u3(p7.origin, p7.origin, p7.basis2), K(p7), p7;
}

export {
  n4 as n,
  I4 as I,
  M4 as M,
  p5 as p,
  m5 as m,
  f6 as f,
  E6 as E,
  S3 as S,
  g8 as g,
  z5 as z,
  v3 as v,
  j11 as j,
  M5 as M2,
  w7 as w,
  D3 as D,
  U3 as U,
  f7 as f2,
  F7 as F,
  c11 as c,
  l8 as l,
  h7 as h,
  V6 as V,
  T5 as T,
  S5 as S2
};
//# sourceMappingURL=chunk-TPVJ435J.js.map
