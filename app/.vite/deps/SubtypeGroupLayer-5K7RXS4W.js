import {
  g2,
  h as h2
} from "./chunk-M6YQSYSW.js";
import {
  I as I2
} from "./chunk-4FQK362J.js";
import {
  T as T2
} from "./chunk-ZD4JXG4O.js";
import {
  u as u5
} from "./chunk-PEVRDPML.js";
import {
  R as R2,
  V as V3
} from "./chunk-44OKV7LZ.js";
import "./chunk-R5QEGUQL.js";
import "./chunk-6WVUJOLD.js";
import "./chunk-YQHLNRT3.js";
import {
  t as t3
} from "./chunk-QLSJI3DL.js";
import {
  i
} from "./chunk-3VG7BBW5.js";
import {
  a as a6
} from "./chunk-TGJTL3DX.js";
import "./chunk-ZROOJR26.js";
import {
  s as s2
} from "./chunk-27HW4PAJ.js";
import {
  n as n4
} from "./chunk-VL6ABOSV.js";
import "./chunk-2KG6WO5I.js";
import {
  C as C3,
  n as n5
} from "./chunk-F23MXZYK.js";
import "./chunk-LZTCFOLV.js";
import "./chunk-FFVHLGAP.js";
import {
  l as l3
} from "./chunk-GCLTWKVB.js";
import {
  d as d3
} from "./chunk-LVOCICBG.js";
import {
  p as p5
} from "./chunk-TNYXYQXK.js";
import {
  w as w2
} from "./chunk-WANI2G7M.js";
import {
  e as e2
} from "./chunk-2O2K2GAF.js";
import {
  l as l2
} from "./chunk-LJBNLWJN.js";
import {
  A as A3,
  B,
  C as C2,
  D,
  E,
  F as F2,
  H,
  L,
  O,
  P,
  R,
  T,
  U,
  V as V4,
  Y,
  q as q2,
  v as v2
} from "./chunk-3GIIPEHS.js";
import {
  p as p4
} from "./chunk-SCNACYSF.js";
import {
  A as A2
} from "./chunk-Q7YUVHCX.js";
import {
  p as p3
} from "./chunk-MG7UOFLP.js";
import "./chunk-ACXFIEER.js";
import "./chunk-PXJIE4N5.js";
import "./chunk-5LA23O74.js";
import "./chunk-4A3WH4AR.js";
import "./chunk-4KREATVZ.js";
import "./chunk-YLPB3XO6.js";
import "./chunk-BTTTF5H4.js";
import "./chunk-MEC6IDRX.js";
import "./chunk-ZH6PYRVF.js";
import "./chunk-MHM4GDCM.js";
import "./chunk-363AT5UF.js";
import "./chunk-CQ2PC3VP.js";
import "./chunk-XUYUNZTH.js";
import {
  S as S2,
  c,
  u as u4
} from "./chunk-HCXUWF52.js";
import "./chunk-ZCYDEY6S.js";
import "./chunk-POMCHIIZ.js";
import "./chunk-5GAOP2C3.js";
import {
  F
} from "./chunk-6WASKRTP.js";
import "./chunk-37HZDVD7.js";
import {
  A
} from "./chunk-3S47CK7X.js";
import {
  j as j2
} from "./chunk-7FOAM45I.js";
import "./chunk-VY225BNN.js";
import {
  f as f3
} from "./chunk-FBQYHS7L.js";
import {
  p
} from "./chunk-LGG5FPVD.js";
import "./chunk-TOMXDOXB.js";
import "./chunk-VTPZW6H5.js";
import {
  t as t2
} from "./chunk-DWXK7D3B.js";
import {
  b
} from "./chunk-EW3YCVZI.js";
import {
  d as d2,
  f,
  j,
  l,
  p as p2,
  u as u3,
  v
} from "./chunk-WZ7EFR6C.js";
import {
  a as a5
} from "./chunk-CVABZLLM.js";
import "./chunk-DDEXP7LW.js";
import "./chunk-KWOLBNIK.js";
import {
  S
} from "./chunk-JLW377TH.js";
import "./chunk-TGMFGDP6.js";
import "./chunk-JST5QDP2.js";
import "./chunk-A4BGGF5Z.js";
import "./chunk-775V3L2A.js";
import {
  b as b2
} from "./chunk-AI2O2GKK.js";
import "./chunk-ANGUSND2.js";
import "./chunk-4NGIUHKX.js";
import "./chunk-FF44HCOD.js";
import "./chunk-AVY6RZDG.js";
import "./chunk-5X74MKXM.js";
import {
  q
} from "./chunk-LCBD3JEK.js";
import "./chunk-IPFYNOOY.js";
import "./chunk-PUC7IJYJ.js";
import "./chunk-ESU5C3MV.js";
import "./chunk-TYJOGWKZ.js";
import "./chunk-4WO6KUCB.js";
import "./chunk-2Y4TRKRB.js";
import "./chunk-XEBZUAYT.js";
import "./chunk-4WERUJEK.js";
import "./chunk-YFLBSX2D.js";
import {
  I as I3,
  g as g3
} from "./chunk-6REABBOQ.js";
import {
  r as r3
} from "./chunk-STBNLAGT.js";
import "./chunk-HSI6V34N.js";
import "./chunk-QTWG47SG.js";
import "./chunk-WJGG35K6.js";
import {
  n as n3
} from "./chunk-ZDVQNOKR.js";
import "./chunk-Y3AY7I5U.js";
import {
  a as a4
} from "./chunk-WJNMFEXQ.js";
import "./chunk-XCRRZPKE.js";
import "./chunk-WZBMMIVS.js";
import "./chunk-WLGGSXQY.js";
import "./chunk-T7KGE6VP.js";
import "./chunk-T57WVICI.js";
import "./chunk-W633AKTD.js";
import "./chunk-UCMTPLHQ.js";
import "./chunk-G34KEQQG.js";
import "./chunk-5EWD56QJ.js";
import "./chunk-3UHB6K6P.js";
import "./chunk-ZYOZHQFS.js";
import {
  t
} from "./chunk-3C7TTTUX.js";
import "./chunk-MLOZK7WX.js";
import "./chunk-XWXWIBVO.js";
import {
  f as f2
} from "./chunk-NTUX5M6N.js";
import "./chunk-FIBMMWXR.js";
import "./chunk-53ZTROGC.js";
import "./chunk-PUM22WTC.js";
import "./chunk-K2PILHWE.js";
import "./chunk-JLFV7EBO.js";
import "./chunk-BV7O6P7Z.js";
import "./chunk-JLFSX3JT.js";
import "./chunk-IP4HFFRO.js";
import "./chunk-PAGKMWJH.js";
import {
  m as m2
} from "./chunk-CHL75CEP.js";
import "./chunk-SQ6MYL73.js";
import "./chunk-HP7OWCUK.js";
import {
  n as n2
} from "./chunk-SWBNCJYN.js";
import "./chunk-NENDDUWH.js";
import "./chunk-YUVX6H42.js";
import {
  o
} from "./chunk-5ESATYIQ.js";
import {
  g,
  r as r2
} from "./chunk-RDUV6YP6.js";
import "./chunk-6P7HXSJ6.js";
import "./chunk-LTDNORB5.js";
import "./chunk-HQLPC24M.js";
import "./chunk-REAPFM7O.js";
import "./chunk-UNGOQUF2.js";
import {
  C,
  d
} from "./chunk-YSPSOPLL.js";
import {
  V as V2
} from "./chunk-AJSC5XSW.js";
import "./chunk-I4HN3ELT.js";
import "./chunk-ACGZOBZ6.js";
import "./chunk-7LY6RE4Z.js";
import "./chunk-AIKBABBU.js";
import "./chunk-A42OBC4U.js";
import "./chunk-BDBI2KVA.js";
import "./chunk-7AOPU62X.js";
import "./chunk-WE4EKKVR.js";
import {
  w
} from "./chunk-UFBX3XSC.js";
import {
  I,
  V
} from "./chunk-F7TCEOHX.js";
import "./chunk-5BULKNR2.js";
import {
  m
} from "./chunk-RYSF6YCR.js";
import {
  a3 as a2,
  u2 as u
} from "./chunk-4LTV6KQ5.js";
import {
  r
} from "./chunk-PPIAYGRE.js";
import "./chunk-L7T5Z7MG.js";
import "./chunk-WCGYJMU3.js";
import "./chunk-577U4F6A.js";
import "./chunk-HS4XAAAN.js";
import "./chunk-STW6HRXO.js";
import "./chunk-7QTMSBS3.js";
import {
  a as a3,
  h,
  k,
  u2
} from "./chunk-M6FNW7GP.js";
import "./chunk-5HI5HAKB.js";
import {
  a,
  e,
  n2 as n,
  s2 as s
} from "./chunk-CWMZW2S5.js";
import "./chunk-2N2W26AY.js";
import "./chunk-JVWSFFO4.js";

// node_modules/@arcgis/core/layers/support/subtypeGroupLayerUtils.js
var f4 = { key: "type", base: p3, errorContext: "renderer", typeMap: { simple: p4, "unique-value": A2, "class-breaks": w2 } };
var i2 = u({ types: f4 });
function c2(e3, r4) {
  var _a;
  const s3 = (_a = e3.drawingInfo) == null ? void 0 : _a.renderer, o2 = s3 ? i2(s3, e3, r4) : null;
  if ("simple" !== (o2 == null ? void 0 : o2.type)) return;
  return h2(o2.symbol, null) ? o2.symbol.clone() : null;
}
var u6 = ["#ed5151", "#149ece", "#a7c636", "#9e559c", "#fc921f", "#ffde3e", "#f789d8", "#b7814a", "#3caf99", "#6b6bd6", "#b54779", "#7f7f7f"];
function a7(r4, s3) {
  return T2(u6, r4, { offset: true, shuffle: true }).reverse().map((e3) => {
    const r5 = s3.clone();
    return "cim" === r5.type ? I2(r5, e3) : g2(r5, e3), new p4({ symbol: r5 });
  });
}

// node_modules/@arcgis/core/layers/support/SubtypeSublayer.js
var $ = s2();
var U2 = 0;
function k2(e3, t4) {
  let r4 = e3.json.write;
  return "object" != typeof r4 && (r4 = e3.json.write = {}), r4.ignoreOrigin = true, (t4 == null ? void 0 : t4.spatialOnly) && (r4.layerContainerTypes = a5), e3;
}
function Q(e3) {
  const t4 = { write: { ignoreOrigin: true } };
  return (e3 == null ? void 0 : e3.name) && (t4.name = e3.name), "object" == typeof t4.write && ((e3 == null ? void 0 : e3.spatialOnly) && (t4.write.layerContainerTypes = a5), (e3 == null ? void 0 : e3.target) && (t4.write.target = e3.target)), t4;
}
function B2(e3) {
  return new p4({ symbol: H2(e3) });
}
function H2(e3) {
  switch (e3) {
    case "point":
    case "multipoint":
      return S2.clone();
    case "polyline":
      return u4.clone();
    case "polygon":
    case "multipatch":
      return c.clone();
    default:
      return null;
  }
}
function J(e3, t4) {
  return !!t4 && ("unique-value" === (e3 == null ? void 0 : e3.type) && null != e3.field && e3.field.toLowerCase() === t4.toLowerCase() && !e3.field2 && !e3.field3 && !e3.valueExpression);
}
function W(e3, t4) {
  var _a;
  return null == e3 ? null : (_a = t4.subtypes) == null ? void 0 : _a.find((t5) => t5.code === e3);
}
function Z(e3, t4) {
  let r4 = null;
  switch (t4.geometryType) {
    case "esriGeometryPoint":
    case "esriGeometryMultipoint":
      r4 = "point";
      break;
    case "esriGeometryPolyline":
      r4 = "line";
      break;
    case "esriGeometryPolygon":
    case "esriGeometryMultiPatch":
      r4 = "polygon";
      break;
    default:
      t4.type, r4 = null;
  }
  const i3 = {}, o2 = W(e3, t4);
  if (null != o2) {
    const { defaultValues: e4 } = o2;
    for (const t5 in e4) i3[t5] = e4[t5];
  }
  return i3[t4.subtypeField] = e3, new n4({ name: "New Feature", drawingTool: r4, prototype: { attributes: i3 } });
}
var z = class extends S(a4.ClonableMixin(n2.IdentifiableMixin(m2))) {
  constructor(e3) {
    super(e3), this.attributeTableTemplate = null, this.charts = null, this.editingEnabled = true, this.fieldOverrides = null, this.fieldsIndex = null, this.formTemplate = null, this.id = `${Date.now().toString(16)}-subtype-sublayer-${U2++}`, this.type = "subtype-sublayer", this.labelsVisible = true, this.labelingInfo = null, this.layerType = "ArcGISFeatureLayer", this.legendEnabled = true, this.listMode = "show", this.minScale = 0, this.maxScale = 0, this.opacity = 1, this.parent = null, this.popupEnabled = true, this.popupTemplate = null, this.subtypeCode = null, this.templates = null, this.title = null, this.visible = true;
  }
  load(e3) {
    return g3(this.renderer, this.fieldsIndex), Promise.resolve(this);
  }
  get _titleCreator() {
    var _a;
    const e3 = this._get("_titleCreator");
    return u2(e3), new u5({ fieldsIndex: this.fieldsIndex, objectIdField: this.objectIdField, displayField: ((_a = this.parent) == null ? void 0 : _a.displayField) ?? "", fields: this.fields, effectivePopupTemplate: this.popupTemplate ?? this.defaultPopupTemplate });
  }
  get capabilities() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.capabilities;
  }
  get effectiveCapabilities() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.effectiveCapabilities;
  }
  get effectiveEditingEnabled() {
    const { parent: e3 } = this;
    return e3 ? e3.effectiveEditingEnabled && this.editingEnabled : this.editingEnabled;
  }
  get elevationInfo() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.elevationInfo;
  }
  get featureTitleFields() {
    return [...this._titleCreator.requiredFields];
  }
  writeFieldOverrides(e3, t4, r4) {
    const { fields: i3, parent: o2 } = this;
    let l4;
    if (i3) {
      l4 = [];
      let e4 = 0;
      i3.forEach(({ name: t5, alias: r5, editable: i4, visible: n6 }) => {
        var _a;
        if (!n6) return;
        const s3 = (_a = o2 == null ? void 0 : o2.fields) == null ? void 0 : _a.find((e5) => e5.name === t5);
        if (!s3) return;
        const a8 = { name: t5 };
        let p6 = false;
        r5 !== s3.alias && (a8.alias = r5, p6 = true), i4 !== s3.editable && (a8.editable = i4, p6 = true), l4.push(a8), p6 && e4++;
      }), 0 === e4 && l4.length === i3.length && (l4 = null);
    } else l4 = a(e3);
    (l4 == null ? void 0 : l4.length) && e(r4, l4, t4);
  }
  get fields() {
    const { parent: e3, fieldOverrides: t4, subtypeCode: r4 } = this, i3 = e3 == null ? void 0 : e3.fields;
    if (!e3 || !(i3 == null ? void 0 : i3.length)) return null;
    const { subtypes: o2, subtypeField: n6 } = e3, l4 = o2 == null ? void 0 : o2.find((e4) => e4.code === r4), s3 = l4 == null ? void 0 : l4.defaultValues, a8 = l4 == null ? void 0 : l4.domains, p6 = [];
    for (const d4 of i3) {
      const e4 = d4.clone(), { name: i4 } = e4, o3 = t4 == null ? void 0 : t4.find((e5) => e5.name === i4);
      if (e4.visible = !(t4 == null ? void 0 : t4.length) || !!o3, o3) {
        const { alias: t5, editable: r5 } = o3;
        t5 && (e4.alias = t5), false === r5 && (e4.editable = false);
      }
      const l5 = (s3 == null ? void 0 : s3[i4]) ?? null;
      e4.defaultValue = i4 === n6 ? r4 : l5;
      const u7 = (a8 == null ? void 0 : a8[i4]) ?? null;
      e4.domain = i4 === n6 ? null : u7 ? "inherited" === u7.type ? e4.domain : u7.clone() : null, p6.push(e4);
    }
    return p6;
  }
  get floorInfo() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.floorInfo;
  }
  get isTable() {
    var _a;
    return !!((_a = this.parent) == null ? void 0 : _a.isTable);
  }
  get geometryType() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.geometryType;
  }
  get globalIdField() {
    return this.parent ? this.parent.globalIdField : (n.getLogger(this).error(Y2("globalIdField")), null);
  }
  get effectiveScaleRange() {
    const { minScale: e3, maxScale: t4 } = this;
    return { minScale: e3, maxScale: t4 };
  }
  get objectIdField() {
    var _a;
    return this.parent || n.getLogger(this).error(Y2("objectIdField")), (_a = this.parent) == null ? void 0 : _a.objectIdField;
  }
  get defaultPopupTemplate() {
    return this.createPopupTemplate();
  }
  get relationships() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.relationships;
  }
  set renderer(e3) {
    g3(e3, this.fieldsIndex), this._override("renderer", e3);
  }
  get renderer() {
    if (this._isOverridden("renderer")) return this._get("renderer");
    const { parent: e3 } = this;
    return e3 && !e3.isTable && "mesh" !== e3.geometryType ? B2(e3.geometryType) : null;
  }
  readRendererFromService(e3, t4, r4) {
    var _a, _b, _c;
    if ("Table" === t4.type) return null;
    const i3 = (_a = t4.drawingInfo) == null ? void 0 : _a.renderer, o2 = i2(i3, t4, r4);
    let n6;
    const { subtypeCode: l4 } = this;
    if (null != l4 && J(o2, t4.subtypeField)) {
      const e4 = (_b = o2.uniqueValueInfos) == null ? void 0 : _b.find(({ value: e5 }) => (e5 = "number" == typeof e5 ? String(e5) : e5) === String(l4));
      e4 && (n6 = new p4({ symbol: e4.symbol }));
    } else "simple" !== (o2 == null ? void 0 : o2.type) || ((_c = o2.visualVariables) == null ? void 0 : _c.length) || (n6 = o2);
    return n6;
  }
  readRenderer(e3, t4, r4) {
    var _a, _b, _c;
    const i3 = (_b = (_a = t4 == null ? void 0 : t4.layerDefinition) == null ? void 0 : _a.drawingInfo) == null ? void 0 : _b.renderer;
    if (!i3) return;
    const o2 = (_c = i3.visualVariables) == null ? void 0 : _c.some((e4) => "rotationInfo" !== e4.type);
    return o2 ? void 0 : i2(i3, t4, r4) || void 0;
  }
  get spatialReference() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.spatialReference) ?? g.WGS84;
  }
  get subtypeField() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.subtypeField;
  }
  readTemplatesFromService(e3, t4) {
    return [Z(this.subtypeCode, t4)];
  }
  readTitleFromService(e3, t4) {
    const r4 = W(this.subtypeCode, t4);
    return null != r4 ? r4.name : null;
  }
  get url() {
    var _a;
    return (_a = this.parent) == null ? void 0 : _a.url;
  }
  get userHasUpdateItemPrivileges() {
    var _a;
    return !!((_a = this.parent) == null ? void 0 : _a.userHasUpdateItemPrivileges);
  }
  async addAttachment(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Y2("addAttachment");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:addAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return r4.addAttachment(e3, t4);
  }
  async updateAttachment(e3, t4, r4) {
    const { parent: o2 } = this;
    if (!o2) throw Y2("updateAttachment");
    if (e3.getAttribute(o2.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:updateAttachment", "The feature provided does not belong to this SubtypeSublayer");
    return o2.updateAttachment(e3, t4, r4);
  }
  async deleteAttachments(e3, t4) {
    const { parent: r4 } = this;
    if (!r4) throw Y2("deleteAttachments");
    if (e3.getAttribute(r4.subtypeField) !== this.subtypeCode) throw new s("subtype-sublayer:deleteAttachments", "The feature provided does not belong to this SubtypeSublayer");
    return r4.deleteAttachments(e3, t4);
  }
  async applyEdits(e3, t4) {
    if (!this.parent) throw Y2("applyEdits");
    return this.parent.applyEdits(e3, t4);
  }
  createPopupTemplate(e3) {
    let t4 = this;
    const { parent: r4, fields: i3, title: o2 } = this;
    if (r4) {
      const { displayField: e4, editFieldsInfo: n6, objectIdField: l4 } = r4;
      t4 = { displayField: e4, editFieldsInfo: n6, fields: i3, objectIdField: l4, title: o2 };
    }
    return p5(t4, e3);
  }
  createQuery() {
    if (!this.parent) throw Y2("createQuery");
    const e3 = R(this.parent), t4 = `${this.parent.subtypeField}=${this.subtypeCode}`;
    return e3.where = r3(t4, this.parent.definitionExpression), e3;
  }
  getFeatureTitle(e3, t4 = { timeZone: "system", fetchMissingFields: false }) {
    return this._titleCreator.getTitle(this, e3, t4);
  }
  getField(e3) {
    return this.fieldsIndex.get(e3);
  }
  getFieldDomain(e3, t4) {
    if (!(t4 == null ? void 0 : t4.excludeImpliedDomains) && this.parent) {
      const t5 = V4(this.parent, e3);
      if (t5) return t5;
    }
    return this._getLayerDomain(e3);
  }
  async queryAttachments(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryAttachments");
    const i3 = e3.clone();
    return i3.where = X(i3.where, r4.parent.subtypeField, r4.subtypeCode), r4.parent.queryAttachments(e3, t4);
  }
  async queryFeatureCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryFeatureCount");
    return r4.parent.queryFeatureCount(K(r4.parent, r4, e3), t4);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryFeatures");
    return r4.parent.queryFeatures(K(r4.parent, r4, e3), t4);
  }
  async queryObjectIds(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryObjectIds");
    return r4.parent.queryObjectIds(K(r4.parent, r4, e3), t4);
  }
  async queryRelatedFeatures(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryRelatedFeatures");
    return r4.parent.queryRelatedFeatures(e3, t4);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    const r4 = await this.load();
    if (!r4.parent) throw Y2("queryRelatedFeaturesCount");
    return r4.parent.queryRelatedFeaturesCount(e3, t4);
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
};
r([m({ clonable: false, readOnly: true })], z.prototype, "_titleCreator", null), r([m({ type: f, json: Q({ name: "attributeTableInfo" }) })], z.prototype, "attributeTableTemplate", void 0), r([m({ readOnly: true, json: { read: false } })], z.prototype, "capabilities", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "effectiveCapabilities", null), r([m({ json: Q() })], z.prototype, "charts", void 0), r([m({ type: Boolean, nonNullable: true, json: Q({ name: "enableEditing" }) })], z.prototype, "editingEnabled", void 0), r([m({ type: Boolean, readOnly: true })], z.prototype, "effectiveEditingEnabled", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "elevationInfo", null), r([m({ clonable: false, readOnly: true })], z.prototype, "featureTitleFields", null), r([m({ json: { name: "layerDefinition.fieldOverrides", origins: { service: { read: false } }, write: { ignoreOrigin: true, allowNull: true } } })], z.prototype, "fieldOverrides", void 0), r([r2("fieldOverrides")], z.prototype, "writeFieldOverrides", null), r([m({ ...$.fields, readOnly: true, json: { read: false } })], z.prototype, "fields", null), r([m($.fieldsIndex)], z.prototype, "fieldsIndex", void 0), r([m({ readOnly: true, json: { read: false } })], z.prototype, "floorInfo", null), r([m({ type: V3, json: Q({ name: "formInfo" }) })], z.prototype, "formTemplate", void 0), r([m({ type: String, clonable: false, json: { origins: { service: { read: false }, "portal-item": { read: false } }, write: { ignoreOrigin: true } } })], z.prototype, "id", void 0), r([m({ readOnly: true, json: { read: false } })], z.prototype, "isTable", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "geometryType", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "globalIdField", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "type", void 0), r([m(k2(a(p2)))], z.prototype, "labelsVisible", void 0), r([m({ type: [C3], json: { name: "layerDefinition.drawingInfo.labelingInfo", origins: { service: { read: false } }, read: { reader: n5 }, write: { ignoreOrigin: true, layerContainerTypes: a5 } } })], z.prototype, "labelingInfo", void 0), r([m({ type: ["ArcGISFeatureLayer"], readOnly: true, json: { read: false, write: { ignoreOrigin: true, layerContainerTypes: a5 } } })], z.prototype, "layerType", void 0), r([m(k2(a(d2)))], z.prototype, "legendEnabled", void 0), r([m({ type: ["show", "hide"] })], z.prototype, "listMode", void 0), r([m((() => {
  const e3 = a(j);
  return e3.json.origins.service.read = false, k2(e3, { spatialOnly: true });
})())], z.prototype, "minScale", void 0), r([m((() => {
  const e3 = a(v);
  return e3.json.origins.service.read = false, k2(e3, { spatialOnly: true });
})())], z.prototype, "maxScale", void 0), r([m({ readOnly: true })], z.prototype, "effectiveScaleRange", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "objectIdField", null), r([m({ type: Number, range: { min: 0, max: 1 }, nonNullable: true, json: Q({ spatialOnly: true }) })], z.prototype, "opacity", void 0), r([m({ clonable: false })], z.prototype, "parent", void 0), r([m(k2(a(l)))], z.prototype, "popupEnabled", void 0), r([m({ type: q, json: Q({ name: "popupInfo" }) })], z.prototype, "popupTemplate", void 0), r([m({ readOnly: true })], z.prototype, "defaultPopupTemplate", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "relationships", null), r([m({ types: f4, json: Q({ target: "layerDefinition.drawingInfo.renderer", spatialOnly: true }) })], z.prototype, "renderer", null), r([o("service", "renderer", ["drawingInfo.renderer", "subtypeField", "type"])], z.prototype, "readRendererFromService", null), r([o("renderer", ["layerDefinition.drawingInfo.renderer"])], z.prototype, "readRenderer", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "spatialReference", null), r([m({ type: Number, json: { origins: { service: { read: false } }, write: { ignoreOrigin: true } } })], z.prototype, "subtypeCode", void 0), r([m({ readOnly: true, json: { read: false } })], z.prototype, "subtypeField", null), r([m({ type: [n4], json: Q({ name: "layerDefinition.templates" }) })], z.prototype, "templates", void 0), r([o("service", "templates", ["geometryType", "subtypeField", "subtypes", "type"])], z.prototype, "readTemplatesFromService", null), r([m({ type: String, json: Q() })], z.prototype, "title", void 0), r([o("service", "title", ["subtypes"])], z.prototype, "readTitleFromService", null), r([m({ readOnly: true, json: { read: false } })], z.prototype, "url", null), r([m({ readOnly: true })], z.prototype, "userHasUpdateItemPrivileges", null), r([m({ type: Boolean, nonNullable: true, json: Q({ name: "visibility", spatialOnly: true }) })], z.prototype, "visible", void 0), z = r([a2("esri.layers.support.SubtypeSublayer")], z);
var K = (e3, t4, r4) => {
  if (!r4) return t4.createQuery();
  const i3 = b2.from(r4);
  return i3.where = X(i3.where, e3.subtypeField, t4.subtypeCode), i3;
};
var X = (e3, t4, r4) => {
  const i3 = new RegExp(`${t4}\\s*=\\s*\\d+`), o2 = `${t4}=${r4}`, n6 = e3 ?? "";
  return i3.test(n6) ? n6.replace(i3, o2) : r3(o2, n6);
};
var Y2 = (e3) => new s(`This sublayer must have a parent SubtypeGroupLayer in order to use ${e3}`);
var ee = z;

// node_modules/@arcgis/core/layers/SubtypeGroupLayer.js
var oe = "SubtypeGroupLayer";
var ae = "esri.layers.SubtypeGroupLayer";
function ne(e3, t4) {
  return new s("layer:unsupported", `Layer (${e3.title}, ${e3.id}) of type '${e3.declaredClass}' ${t4}`, { layer: e3 });
}
function le(e3, t4) {
  const r4 = [];
  for (const s3 of e3) {
    const e4 = new ee();
    e4.read(s3, t4), r4.push(e4);
  }
  return r4;
}
var ue = s2();
function pe() {
  return { name: "layerType", read: { enabled: true }, write: { enabled: true, ignoreOrigin: true, isRequired: true } };
}
var ye = class extends R2(a6(F(p(l3(t2(f3(l2(b(j2(S(e2(i(a4.ClonableMixin(f2)))))))))))))) {
  constructor(...e3) {
    super(...e3), this._sublayerLookup = /* @__PURE__ */ new Map(), this.fields = null, this.fieldsIndex = null, this.outFields = null, this.sublayers = new (V2.ofType(ee))(), this.useUniqueColorsForSublayers = true, this.supportedSourceTypes = /* @__PURE__ */ new Set(["Feature Layer", "Table"]), this.timeInfo = null, this.title = "Layer", this.type = "subtype-group", this._debouncedSaveOperations = k(async (e4, t4, r4) => {
      const { save: s3, saveAs: i3 } = await import("./featureLayerUtils-TGTOJA3L.js");
      switch (e4) {
        case A.SAVE:
          return s3(this, t4);
        case A.SAVE_AS:
          return i3(this, r4, t4);
      }
    }), this.addHandles(d(() => this.sublayers, (e4, t4) => this._handleSublayersChange(e4, t4), C));
  }
  destroy() {
    var _a;
    (_a = this.source) == null ? void 0 : _a.destroy();
  }
  normalizeCtorArgs(e3, t4) {
    return "string" == typeof e3 ? { url: e3, ...t4 } : e3;
  }
  load(e3) {
    const t4 = null != e3 ? e3.signal : null, r4 = this.loadFromPortal({ supportedTypes: ["Feature Service"] }, e3).catch(a3).then(async () => {
      if (!this.url) throw new s("subtype-grouplayer:missing-url-or-source", "SubtypeGroupLayer must be created with either a url or a portal item");
      if (null == this.layerId) throw new s("subtype-grouplayer:missing-layerid", "layerId is required for a SubtypeGroupLayer created with url");
      return this._initLayerProperties(await this.createGraphicsSource(t4));
    }).then(() => H(this, "load", e3));
    return this.addResolvingPromise(r4), Promise.resolve(this);
  }
  get createQueryVersion() {
    return this.commitProperty("definitionExpression"), this.commitProperty("timeExtent"), this.commitProperty("timeOffset"), this.commitProperty("geometryType"), this.commitProperty("gdbVersion"), this.commitProperty("historicMoment"), this.commitProperty("returnZ"), this.commitProperty("capabilities"), this.commitProperty("returnM"), (this._get("createQueryVersion") ?? 0) + 1;
  }
  get editingEnabled() {
    return this.loaded && null != this.capabilities && this.capabilities.operations.supportsEditing && this.userHasEditingPrivileges;
  }
  get effectiveEditingEnabled() {
    return Y(this);
  }
  get operationalLayerType() {
    return this.isTable ? "SubtypeGroupTable" : "SubtypeGroupLayer";
  }
  get parsedUrl() {
    const e3 = I(this.url);
    return null != e3 && null != this.layerId && (e3.path = V(e3.path, this.layerId.toString())), e3;
  }
  set source(e3) {
    this._get("source") !== e3 && this._set("source", e3);
  }
  readTitleFromService(e3, { name: t4 }) {
    return this.url ? w(this.url, t4) : t4;
  }
  async addAttachment(e3, t4) {
    const r4 = await F2(this, e3, t4, oe);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async updateAttachment(e3, t4, r4) {
    const s3 = await P(this, e3, t4, r4, oe);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), s3;
  }
  async applyEdits(e3, t4) {
    return q2(this, e3, t4);
  }
  on(e3, t4) {
    return super.on(e3, t4);
  }
  async createGraphicsSource(e3) {
    const { default: t4 } = await h(import("./FeatureLayerSource-I5OX2WL2.js"), e3);
    return new t4({ layer: this, supportedSourceTypes: this.supportedSourceTypes }).load({ signal: e3 });
  }
  createQuery() {
    const e3 = R(this), t4 = this.sublayers.map((e4) => e4.subtypeCode);
    return e3.where = r3(`${this.subtypeField} IN (${t4.join(",")})`, this.definitionExpression), e3;
  }
  async deleteAttachments(e3, t4) {
    const r4 = await v2(this, e3, t4, oe);
    return this.lastEditsEventDate = /* @__PURE__ */ new Date(), r4;
  }
  async fetchRecomputedExtents(e3) {
    return O(this, e3, oe);
  }
  findSublayerForFeature(e3) {
    const t4 = this.fieldsIndex.get(this.subtypeField), r4 = e3.attributes[t4.name];
    return this.findSublayerForSubtypeCode(r4);
  }
  findSublayerForSubtypeCode(e3) {
    return this._sublayerLookup.get(e3);
  }
  getFieldDomain(e3, t4) {
    var _a;
    if (!(t4 == null ? void 0 : t4.excludeImpliedDomains)) {
      const t5 = V4(this, e3);
      if (t5) return t5;
    }
    const r4 = U(this, t4 == null ? void 0 : t4.feature);
    if (r4) {
      const t5 = (_a = r4.domains) == null ? void 0 : _a[e3];
      return "inherited" === (t5 == null ? void 0 : t5.type) ? this._getLayerDomain(e3) : t5;
    }
    return this._getLayerDomain(e3);
  }
  loadAll() {
    return t(this, (e3) => {
      e3(this.sublayers);
    });
  }
  async queryAttachments(e3, t4) {
    return A3(this, e3, t4, oe);
  }
  async queryFeatures(e3, t4) {
    const r4 = await this.load(), s3 = b2.from(e3) ?? r4.createQuery(), i3 = s3.outFields ?? [];
    i3.includes(this.subtypeField) || (i3.push(this.subtypeField), s3.outFields = i3);
    const o2 = await r4.source.queryFeatures(s3, t4);
    if (o2 == null ? void 0 : o2.features) for (const a8 of o2.features) a8.layer = a8.sourceLayer = this.findSublayerForFeature(a8);
    return o2;
  }
  async queryObjectIds(e3, t4) {
    return (await L(this, e3, t4, oe)).filter(n3);
  }
  async queryFeatureCount(e3, t4) {
    return E(this, e3, t4, oe);
  }
  async queryExtent(e3, t4) {
    return D(this, e3, t4, oe);
  }
  async queryRelatedFeatures(e3, t4) {
    return T(this, e3, t4, oe);
  }
  async queryRelatedFeaturesCount(e3, t4) {
    return C2(this, e3, t4, oe);
  }
  async save(e3) {
    return this._debouncedSaveOperations(A.SAVE, e3);
  }
  async saveAs(e3, t4) {
    return this._debouncedSaveOperations(A.SAVE_AS, t4, e3);
  }
  write(e3, t4) {
    var _a;
    const { origin: r4, layerContainerType: i3, messages: o2 } = t4;
    if (this.isTable) {
      if ("web-scene" === r4 || "web-map" === r4 && "tables" !== i3) return o2 == null ? void 0 : o2.push(ne(this, "using a table source cannot be written to web scenes and web maps")), null;
    } else if (this.loaded && "web-map" === r4 && "tables" === i3) return o2 == null ? void 0 : o2.push(ne(this, "using a non-table source cannot be written to tables in web maps")), null;
    return ((_a = this.sublayers) == null ? void 0 : _a.length) ? super.write(e3, t4) : (o2 == null ? void 0 : o2.push(new s("web-document-write:invalid-property", `Layer (${this.title}, ${this.id}) of type '${this.declaredClass}' has invalid value for 'sublayers' property. 'sublayers' collection should contain at least one sublayer`, { layer: this })), null);
  }
  serviceSupportsSpatialReference(e3) {
    return !!this.loaded && t3(this, e3);
  }
  async getFeatureTitle(e3, t4 = { timeZone: "system", fetchMissingFields: false }) {
    const r4 = this.findSublayerForFeature(e3);
    return r4 ? await r4.getFeatureTitle(e3, t4) : this.displayField && this.fieldsIndex.has(this.displayField) ? e3.attributes[this.fieldsIndex.get(this.displayField).name] ?? "" : this.objectIdField && this.fieldsIndex.has(this.objectIdField) ? e3.attributes[this.fieldsIndex.get(this.objectIdField).name] ?? "" : "";
  }
  get featureTitleFields() {
    const e3 = /* @__PURE__ */ new Set();
    for (const t4 of this.sublayers) {
      const r4 = t4.featureTitleFields;
      for (const t5 of r4) e3.add(t5);
    }
    return [...e3];
  }
  _getLayerDomain(e3) {
    const t4 = this.fieldsIndex.get(e3);
    return t4 ? t4.domain : null;
  }
  async _initLayerProperties(e3) {
    var _a;
    this._set("source", e3);
    const { sourceJSON: t4 } = e3;
    if (t4 && (this.sourceJSON = t4, this.read(t4, { origin: "service", url: this.parsedUrl })), !((_a = this.subtypes) == null ? void 0 : _a.length)) throw new s("subtype-grouplayer:missing-subtypes", "SubtypeGroupLayer must be created using a layer with subtypes");
    this._verifyFields(), I3(this.timeInfo, this.fieldsIndex);
  }
  async hasDataChanged() {
    return B(this);
  }
  _verifyFields() {
    var _a, _b;
    const e3 = ((_a = this.parsedUrl) == null ? void 0 : _a.path) ?? "undefined";
    this.objectIdField || console.log("SubtypeGroupLayer: 'objectIdField' property is not defined (url: " + e3 + ")"), this.isTable || -1 !== e3.search(/\/FeatureServer\//i) || ((_b = this.fields) == null ? void 0 : _b.some((e4) => "geometry" === e4.type)) || console.log("SubtypeGroupLayer: unable to find field of type 'geometry' in the layer 'fields' list. If you are using a map service layer, features will not have geometry (url: " + e3 + ")");
  }
  _handleSublayersChange(e3, t4) {
    t4 && (t4.forEach((e4) => {
      e4.parent = null;
    }), this.removeHandles("sublayers-owner"), this._sublayerLookup.clear()), e3 && (e3.forEach((e4) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), this.addHandles([e3.on("after-add", ({ item: e4 }) => {
      e4.parent = this, this._sublayerLookup.set(e4.subtypeCode, e4);
    }), e3.on("after-remove", ({ item: e4 }) => {
      e4.parent = null, this._sublayerLookup.delete(e4.subtypeCode);
    })], "sublayers-owner"));
  }
};
r([m({ readOnly: true })], ye.prototype, "createQueryVersion", null), r([m({ readOnly: true })], ye.prototype, "editingEnabled", null), r([m({ readOnly: true })], ye.prototype, "effectiveEditingEnabled", null), r([m({ ...ue.fields, readOnly: true, json: { origins: { service: { read: true } }, read: false } })], ye.prototype, "fields", void 0), r([m(ue.fieldsIndex)], ye.prototype, "fieldsIndex", void 0), r([m(u3)], ye.prototype, "id", void 0), r([m({ type: ["show", "hide", "hide-children"], json: { origins: { "portal-item": { read: false, write: false } } } })], ye.prototype, "listMode", void 0), r([m({ type: ["SubtypeGroupLayer", "SubtypeGroupTable"], json: { ...pe(), origins: { "web-document": pe(), "portal-item": pe() } } })], ye.prototype, "operationalLayerType", null), r([m(ue.outFields)], ye.prototype, "outFields", void 0), r([m({ readOnly: true })], ye.prototype, "parsedUrl", null), r([m({ clonable: false })], ye.prototype, "source", null), r([m({ type: V2.ofType(ee), json: { origins: { service: { read: { source: "subtypes", reader(e3, t4, s3) {
  let i3 = null;
  if (this.useUniqueColorsForSublayers) {
    const r4 = c2(t4, s3);
    i3 = r4 ? a7(e3.length, r4) : null;
  }
  const o2 = e3.map(({ code: e4 }, r4) => {
    const o3 = new ee({ subtypeCode: e4 });
    o3.read(t4, s3);
    const a8 = i3 == null ? void 0 : i3[r4];
    return a8 && o3.read({ drawingInfo: { renderer: a8.toJSON() } }, s3), o3;
  });
  return new (V2.ofType(ee))(o2);
} } } }, read: { source: ["layers", "tables"], reader(e3, t4, s3) {
  var _a, _b;
  let i3;
  return "SubtypeGroupLayer" === t4.layerType && ((_a = t4.layers) == null ? void 0 : _a.length) ? i3 = le(t4.layers, s3) : "SubtypeGroupTable" === t4.layerType && ((_b = t4.tables) == null ? void 0 : _b.length) && (i3 = le(t4.tables, s3)), new (V2.ofType(ee))(i3);
} }, write: { ignoreOrigin: true, writer(e3, t4, r4, s3) {
  const i3 = [];
  for (const o2 of e3) {
    const e4 = o2.write({}, s3);
    i3.push(e4);
  }
  this.isTable ? t4.tables = i3 : t4.layers = i3;
} } } })], ye.prototype, "sublayers", void 0), r([m()], ye.prototype, "useUniqueColorsForSublayers", void 0), r([m({ type: d3 })], ye.prototype, "timeInfo", void 0), r([m({ json: { origins: { "portal-item": { write: { enabled: true, ignoreOrigin: true, writerEnsuresNonNull: true } } } } })], ye.prototype, "title", void 0), r([o("service", "title", ["name"])], ye.prototype, "readTitleFromService", null), r([m({ json: { read: false } })], ye.prototype, "type", void 0), r([m({ clonable: false, readOnly: true })], ye.prototype, "featureTitleFields", null), ye = r([a2(ae)], ye);
var de = ye;
export {
  de as default
};
//# sourceMappingURL=SubtypeGroupLayer-5K7RXS4W.js.map
