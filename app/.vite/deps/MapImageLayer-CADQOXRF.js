import {
  y as y2
} from "./chunk-RHMRUA5L.js";
import "./chunk-H263NTAU.js";
import {
  f as f3,
  m as m2
} from "./chunk-N2XHYZSK.js";
import {
  e as e3,
  se
} from "./chunk-VDYWILM2.js";
import "./chunk-QVL6U5IE.js";
import "./chunk-JJDD37IJ.js";
import "./chunk-F7TFMQ3A.js";
import "./chunk-GEXVSPF3.js";
import "./chunk-3B5XHATW.js";
import "./chunk-5UCWBFBR.js";
import "./chunk-22F4IMT5.js";
import "./chunk-5WX74QOU.js";
import "./chunk-YRSM2W7P.js";
import "./chunk-EM6PL3GZ.js";
import "./chunk-J7454WTE.js";
import "./chunk-U6JFTJMZ.js";
import "./chunk-TSDCR4OY.js";
import {
  t as t3
} from "./chunk-A4ZIOFBT.js";
import "./chunk-67XXGAOA.js";
import "./chunk-4TZUFQZG.js";
import "./chunk-R5QEGUQL.js";
import "./chunk-6WVUJOLD.js";
import "./chunk-YQHLNRT3.js";
import "./chunk-G7HNCC5G.js";
import {
  t as t4
} from "./chunk-QLSJI3DL.js";
import {
  i
} from "./chunk-3VG7BBW5.js";
import "./chunk-VL6ABOSV.js";
import {
  i as i2
} from "./chunk-2KG6WO5I.js";
import "./chunk-D4RMC5GM.js";
import "./chunk-BWQFRI3E.js";
import "./chunk-F23MXZYK.js";
import "./chunk-LZTCFOLV.js";
import "./chunk-J6MQFQDT.js";
import "./chunk-RAXTPGM6.js";
import "./chunk-FFVHLGAP.js";
import {
  l as l2
} from "./chunk-GCLTWKVB.js";
import "./chunk-LVOCICBG.js";
import "./chunk-TNYXYQXK.js";
import "./chunk-WANI2G7M.js";
import {
  e as e2
} from "./chunk-2O2K2GAF.js";
import {
  l
} from "./chunk-LJBNLWJN.js";
import "./chunk-3GIIPEHS.js";
import "./chunk-SCNACYSF.js";
import "./chunk-Q7YUVHCX.js";
import "./chunk-MG7UOFLP.js";
import "./chunk-ACXFIEER.js";
import "./chunk-PXJIE4N5.js";
import "./chunk-5LA23O74.js";
import "./chunk-4A3WH4AR.js";
import "./chunk-4KREATVZ.js";
import "./chunk-YLPB3XO6.js";
import "./chunk-DMXES2BK.js";
import "./chunk-ONZPKEDE.js";
import "./chunk-BTTTF5H4.js";
import "./chunk-MEC6IDRX.js";
import "./chunk-ZH6PYRVF.js";
import "./chunk-MHM4GDCM.js";
import "./chunk-363AT5UF.js";
import "./chunk-CQ2PC3VP.js";
import "./chunk-XUYUNZTH.js";
import "./chunk-HCXUWF52.js";
import "./chunk-ZCYDEY6S.js";
import "./chunk-POMCHIIZ.js";
import "./chunk-5GAOP2C3.js";
import "./chunk-37HZDVD7.js";
import {
  j
} from "./chunk-7FOAM45I.js";
import "./chunk-VY225BNN.js";
import {
  f as f2
} from "./chunk-FBQYHS7L.js";
import {
  p as p2
} from "./chunk-LGG5FPVD.js";
import "./chunk-TOMXDOXB.js";
import "./chunk-VTPZW6H5.js";
import {
  t as t2
} from "./chunk-DWXK7D3B.js";
import {
  b as b2
} from "./chunk-EW3YCVZI.js";
import {
  y
} from "./chunk-WZ7EFR6C.js";
import "./chunk-CVABZLLM.js";
import "./chunk-DDEXP7LW.js";
import "./chunk-KWOLBNIK.js";
import {
  S
} from "./chunk-JLW377TH.js";
import "./chunk-TGMFGDP6.js";
import "./chunk-JST5QDP2.js";
import "./chunk-A4BGGF5Z.js";
import "./chunk-AI2O2GKK.js";
import "./chunk-ANGUSND2.js";
import "./chunk-WF2ACUGU.js";
import "./chunk-4NGIUHKX.js";
import "./chunk-FF44HCOD.js";
import "./chunk-AVY6RZDG.js";
import "./chunk-JJAT7JGD.js";
import "./chunk-D4CSBMND.js";
import "./chunk-5X74MKXM.js";
import "./chunk-LCBD3JEK.js";
import "./chunk-IPFYNOOY.js";
import "./chunk-PUC7IJYJ.js";
import "./chunk-ESU5C3MV.js";
import "./chunk-TYJOGWKZ.js";
import "./chunk-4WO6KUCB.js";
import "./chunk-2Y4TRKRB.js";
import "./chunk-XEBZUAYT.js";
import "./chunk-4WERUJEK.js";
import "./chunk-YFLBSX2D.js";
import "./chunk-6REABBOQ.js";
import "./chunk-STBNLAGT.js";
import "./chunk-HSI6V34N.js";
import "./chunk-QTWG47SG.js";
import "./chunk-WJGG35K6.js";
import "./chunk-ZDVQNOKR.js";
import "./chunk-Y3AY7I5U.js";
import "./chunk-WJNMFEXQ.js";
import "./chunk-XCRRZPKE.js";
import "./chunk-WZBMMIVS.js";
import "./chunk-WLGGSXQY.js";
import "./chunk-T7KGE6VP.js";
import "./chunk-T57WVICI.js";
import "./chunk-W633AKTD.js";
import "./chunk-UCMTPLHQ.js";
import "./chunk-G34KEQQG.js";
import "./chunk-5EWD56QJ.js";
import "./chunk-3UHB6K6P.js";
import "./chunk-ZYOZHQFS.js";
import {
  t
} from "./chunk-3C7TTTUX.js";
import "./chunk-45XNKFWX.js";
import "./chunk-MLOZK7WX.js";
import "./chunk-XWXWIBVO.js";
import {
  f
} from "./chunk-NTUX5M6N.js";
import "./chunk-FIBMMWXR.js";
import "./chunk-53ZTROGC.js";
import "./chunk-PUM22WTC.js";
import "./chunk-K2PILHWE.js";
import "./chunk-JLFV7EBO.js";
import "./chunk-BV7O6P7Z.js";
import "./chunk-JLFSX3JT.js";
import "./chunk-IP4HFFRO.js";
import "./chunk-PAGKMWJH.js";
import "./chunk-CHL75CEP.js";
import {
  p
} from "./chunk-SQ6MYL73.js";
import "./chunk-HP7OWCUK.js";
import "./chunk-SWBNCJYN.js";
import {
  w
} from "./chunk-NENDDUWH.js";
import "./chunk-YUVX6H42.js";
import {
  o
} from "./chunk-5ESATYIQ.js";
import {
  r as r2
} from "./chunk-RDUV6YP6.js";
import "./chunk-6P7HXSJ6.js";
import {
  c
} from "./chunk-LTDNORB5.js";
import "./chunk-HQLPC24M.js";
import "./chunk-REAPFM7O.js";
import {
  a as a2
} from "./chunk-UNGOQUF2.js";
import "./chunk-YSPSOPLL.js";
import "./chunk-AJSC5XSW.js";
import "./chunk-I4HN3ELT.js";
import "./chunk-ACGZOBZ6.js";
import "./chunk-7LY6RE4Z.js";
import "./chunk-AIKBABBU.js";
import "./chunk-A42OBC4U.js";
import "./chunk-BDBI2KVA.js";
import "./chunk-7AOPU62X.js";
import "./chunk-WE4EKKVR.js";
import {
  P2 as P
} from "./chunk-UFBX3XSC.js";
import "./chunk-F7TCEOHX.js";
import "./chunk-5BULKNR2.js";
import {
  e,
  m,
  n2 as n
} from "./chunk-RYSF6YCR.js";
import {
  a3 as a,
  x
} from "./chunk-4LTV6KQ5.js";
import {
  r
} from "./chunk-PPIAYGRE.js";
import "./chunk-L7T5Z7MG.js";
import "./chunk-WCGYJMU3.js";
import "./chunk-577U4F6A.js";
import "./chunk-HS4XAAAN.js";
import "./chunk-STW6HRXO.js";
import "./chunk-7QTMSBS3.js";
import {
  a as a3,
  b
} from "./chunk-M6FNW7GP.js";
import "./chunk-5HI5HAKB.js";
import {
  s2 as s
} from "./chunk-CWMZW2S5.js";
import "./chunk-2N2W26AY.js";
import "./chunk-JVWSFFO4.js";

// node_modules/@arcgis/core/layers/MapImageLayer.js
var J = class extends p2(l2(t2(m2(f3(l(b2(j(S(f2(i(e2(f)))))))))))) {
  constructor(...e4) {
    super(...e4), this._exportImageParameters = new y2({ layer: this }), this.dateFieldsTimeZone = null, this.datesInUnknownTimezone = false, this.dpi = 96, this.gdbVersion = null, this.imageFormat = "png24", this.imageMaxHeight = 2048, this.imageMaxWidth = 2048, this.imageTransparency = true, this.isReference = null, this.labelsVisible = false, this.operationalLayerType = "ArcGISMapServiceLayer", this.preferredTimeZone = null, this.sourceJSON = null, this.sublayers = null, this.type = "map-image", this.url = null;
  }
  normalizeCtorArgs(e4, r3) {
    return "string" == typeof e4 ? { url: e4, ...r3 } : e4;
  }
  load(e4) {
    const r3 = null != e4 ? e4.signal : null;
    return this.addResolvingPromise(this.loadFromPortal({ supportedTypes: ["Map Service"] }, e4).catch(a3).then(() => this._fetchService(r3))), Promise.resolve(this);
  }
  destroy() {
    this._exportImageParameters.destroy();
  }
  readImageFormat(e4, r3) {
    const t5 = r3.supportedImageFormatTypes;
    return t5 && t5.includes("PNG32") ? "png32" : "png24";
  }
  writeSublayers(e4, r3, t5, i3) {
    var _a, _b, _c;
    if (!this.loaded || !e4) return;
    const s2 = e4.slice().reverse().flatten(({ sublayers: e5 }) => e5 && e5.toArray().reverse()).toArray();
    let o2 = false;
    const a4 = n(i3.origin);
    if (((_a = this.capabilities) == null ? void 0 : _a.operations.supportsExportMap) && ((_c = (_b = this.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsDynamicLayers)) {
      if (a4 === e.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("service").sublayers;
        o2 = e3(s2, e5, e.SERVICE);
      } else if (a4 > e.PORTAL_ITEM) {
        const e5 = this.createSublayersForOrigin("portal-item");
        o2 = e3(s2, e5.sublayers, n(e5.origin));
      }
    }
    const p3 = [], n2 = { writeSublayerStructure: o2, ...i3 };
    let m3 = o2 || this.hasVisibleLayersForOrigin(a4);
    s2.forEach((e5) => {
      const r4 = e5.write({}, n2);
      p3.push(r4), m3 = m3 || "user" === e5.originOf("visible");
    });
    p3.some((e5) => Object.keys(e5).length > 1) && (r3.layers = p3), m3 && (r3.visibleLayers = s2.filter((e5) => e5.visible).map((e5) => e5.id));
  }
  createExportImageParameters(e4, r3, t5, i3) {
    const s2 = (i3 == null ? void 0 : i3.pixelRatio) || 1;
    e4 && this.version >= 10 && (e4 = e4.clone().shiftCentralMeridian()), this._exportImageParameters.floors = (i3 == null ? void 0 : i3.floors) ?? null, this._exportImageParameters.scale = i2({ extent: e4, width: r3 }) * s2;
    const o2 = this._exportImageParameters.toJSON(), a4 = !(i3 == null ? void 0 : i3.rotation) || this.version < 10.3 ? {} : { rotation: -i3.rotation }, p3 = e4 == null ? void 0 : e4.spatialReference, n2 = c(p3);
    o2.dpi *= s2;
    const m3 = {};
    if (i3 == null ? void 0 : i3.timeExtent) {
      const { start: e5, end: r4 } = i3.timeExtent.toJSON();
      m3.time = e5 && r4 && e5 === r4 ? "" + e5 : `${e5 ?? "null"},${r4 ?? "null"}`;
    } else this.timeInfo && !this.timeInfo.hasLiveData && (m3.time = "null,null");
    return { bbox: e4 ? e4.xmin + "," + e4.ymin + "," + e4.xmax + "," + e4.ymax : void 0, bboxSR: n2, imageSR: n2, size: r3 + "," + t5, ...o2, ...a4, ...m3 };
  }
  async fetchImage(e4, r3, t5, i3) {
    const { data: s2 } = await this._fetchImage("image", e4, r3, t5, i3);
    return s2;
  }
  async fetchImageBitmap(e4, r3, t5, i3) {
    const { data: s2, url: o2 } = await this._fetchImage("blob", e4, r3, t5, i3);
    return t3(s2, o2, i3 == null ? void 0 : i3.signal);
  }
  async fetchRecomputedExtents(e4 = {}) {
    const t5 = { ...e4, query: { returnUpdates: true, f: "json", ...this.customParameters, token: this.apiKey } }, { data: i3 } = await P(this.url, t5), { extent: s2, fullExtent: o2, timeExtent: a4 } = i3, p3 = s2 || o2;
    return { fullExtent: p3 && w.fromJSON(p3), timeExtent: a4 && p.fromJSON({ start: a4[0], end: a4[1] }) };
  }
  loadAll() {
    return t(this, (e4) => {
      e4(this.allSublayers), e4(this.subtables);
    });
  }
  serviceSupportsSpatialReference(e4) {
    return t4(this, e4);
  }
  async _fetchImage(e4, i3, s2, o2, p3) {
    var _a, _b, _c;
    const n2 = { responseType: e4, signal: (p3 == null ? void 0 : p3.signal) ?? null, query: { ...this.parsedUrl.query, ...this.createExportImageParameters(i3, s2, o2, p3), f: "image", ...this.refreshParameters, ...this.customParameters, token: this.apiKey } }, m3 = this.parsedUrl.path + "/export";
    if (null != ((_a = n2.query) == null ? void 0 : _a.dynamicLayers) && !((_c = (_b = this.capabilities) == null ? void 0 : _b.exportMap) == null ? void 0 : _c.supportsDynamicLayers)) throw new s("mapimagelayer:dynamiclayer-not-supported", `service ${this.url} doesn't support dynamic layers, which is required to be able to change the sublayer's order, rendering, labeling or source.`, { query: n2.query });
    try {
      const { data: e5 } = await P(m3, n2);
      return { data: e5, url: m3 };
    } catch (l3) {
      if (b(l3)) throw l3;
      throw new s("mapimagelayer:image-fetch-error", `Unable to load image: ${m3}`, { error: l3 });
    }
  }
  async _fetchService(e4) {
    if (this.sourceJSON) return void this.read(this.sourceJSON, { origin: "service", url: this.parsedUrl });
    const { data: t5, ssl: i3 } = await P(this.parsedUrl.path, { query: { f: "json", ...this.parsedUrl.query, ...this.customParameters, token: this.apiKey }, signal: e4 });
    i3 && (this.url = this.url.replace(/^http:/i, "https:")), this.sourceJSON = t5, this.read(t5, { origin: "service", url: this.parsedUrl });
  }
  hasVisibleLayersForOrigin(e4) {
    var _a;
    return !(null == e4 || !((_a = this.sublayersSourceJSON[e4]) == null ? void 0 : _a.visibleLayers));
  }
};
r([m(a2("dateFieldsTimeReference"))], J.prototype, "dateFieldsTimeZone", void 0), r([m({ type: Boolean })], J.prototype, "datesInUnknownTimezone", void 0), r([m()], J.prototype, "dpi", void 0), r([m()], J.prototype, "gdbVersion", void 0), r([m()], J.prototype, "imageFormat", void 0), r([o("imageFormat", ["supportedImageFormatTypes"])], J.prototype, "readImageFormat", null), r([m({ json: { origins: { service: { read: { source: "maxImageHeight" } } } } })], J.prototype, "imageMaxHeight", void 0), r([m({ json: { origins: { service: { read: { source: "maxImageWidth" } } } } })], J.prototype, "imageMaxWidth", void 0), r([m()], J.prototype, "imageTransparency", void 0), r([m({ type: Boolean, json: { read: false, write: { enabled: true, overridePolicy: () => ({ enabled: false }) } } })], J.prototype, "isReference", void 0), r([m({ json: { read: false, write: false } })], J.prototype, "labelsVisible", void 0), r([m({ type: ["ArcGISMapServiceLayer"] })], J.prototype, "operationalLayerType", void 0), r([m({ json: { read: false, write: false } })], J.prototype, "popupEnabled", void 0), r([m(a2("preferredTimeReference"))], J.prototype, "preferredTimeZone", void 0), r([m()], J.prototype, "sourceJSON", void 0), r([m({ json: { write: { ignoreOrigin: true } } })], J.prototype, "sublayers", void 0), r([r2("sublayers", { layers: { type: [se] }, visibleLayers: { type: [x] } })], J.prototype, "writeSublayers", null), r([m({ type: ["show", "hide", "hide-children"] })], J.prototype, "listMode", void 0), r([m({ json: { read: false }, readOnly: true, value: "map-image" })], J.prototype, "type", void 0), r([m(y)], J.prototype, "url", void 0), J = r([a("esri.layers.MapImageLayer")], J);
var q = J;
export {
  q as default
};
//# sourceMappingURL=MapImageLayer-CADQOXRF.js.map
