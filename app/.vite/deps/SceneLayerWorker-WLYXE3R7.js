import "./chunk-TUAURE3Q.js";
import "./chunk-MAMFTXBR.js";
import "./chunk-F4RJF7LN.js";
import "./chunk-GTKHPYCP.js";
import "./chunk-NQPBPVRE.js";
import "./chunk-EOMGQOKR.js";
import "./chunk-BDV3SAJ7.js";
import "./chunk-LZUCOHH2.js";
import "./chunk-KXYJDLD2.js";
import "./chunk-HV35YTAC.js";
import "./chunk-LAXBDZHV.js";
import "./chunk-KJG6NJ7J.js";
import "./chunk-3AY7Y7FP.js";
import "./chunk-BSNHCIEC.js";
import "./chunk-U5M766SV.js";
import "./chunk-OZ4EAB4F.js";
import "./chunk-D7JG6K4Y.js";
import "./chunk-WAKNRSGF.js";
import "./chunk-NATJDMSF.js";
import "./chunk-EJHUCCX3.js";
import "./chunk-4T44Z66D.js";
import "./chunk-OULJFYM2.js";
import "./chunk-NWA7NYLF.js";
import "./chunk-ZAYRG6WM.js";
import "./chunk-PM2PTAZQ.js";
import "./chunk-NVEHOQKI.js";
import {
  d,
  n as n4
} from "./chunk-U2TKRMQE.js";
import "./chunk-IWFYZGBP.js";
import "./chunk-H2PMLL3X.js";
import "./chunk-ZKPJPNLW.js";
import {
  a,
  n as n3
} from "./chunk-A6DPK5GC.js";
import "./chunk-HONYA6AI.js";
import "./chunk-NOMJWA3C.js";
import "./chunk-X5RZJMNW.js";
import "./chunk-K24WU5UX.js";
import "./chunk-U7ERRXB6.js";
import "./chunk-O2L6JAHP.js";
import "./chunk-LH36NQSN.js";
import "./chunk-UMYFDXOJ.js";
import "./chunk-MHM4GDCM.js";
import "./chunk-363AT5UF.js";
import "./chunk-QM4DRRZI.js";
import "./chunk-LPMFP5XM.js";
import "./chunk-AI2O2GKK.js";
import "./chunk-ANGUSND2.js";
import "./chunk-4NGIUHKX.js";
import "./chunk-FF44HCOD.js";
import "./chunk-AVY6RZDG.js";
import "./chunk-4WERUJEK.js";
import "./chunk-YFLBSX2D.js";
import "./chunk-QTWG47SG.js";
import "./chunk-WJGG35K6.js";
import "./chunk-SUVHJC6Z.js";
import "./chunk-WJNMFEXQ.js";
import "./chunk-XCRRZPKE.js";
import "./chunk-WZBMMIVS.js";
import "./chunk-WLGGSXQY.js";
import "./chunk-T7KGE6VP.js";
import "./chunk-T57WVICI.js";
import "./chunk-W633AKTD.js";
import "./chunk-UCMTPLHQ.js";
import "./chunk-G34KEQQG.js";
import "./chunk-3UHB6K6P.js";
import "./chunk-ZYOZHQFS.js";
import "./chunk-53ZTROGC.js";
import "./chunk-PUM22WTC.js";
import "./chunk-JLFV7EBO.js";
import "./chunk-BV7O6P7Z.js";
import {
  n as n2
} from "./chunk-JLFSX3JT.js";
import "./chunk-SQ6MYL73.js";
import "./chunk-HP7OWCUK.js";
import "./chunk-NENDDUWH.js";
import "./chunk-YUVX6H42.js";
import "./chunk-5ESATYIQ.js";
import {
  g
} from "./chunk-RDUV6YP6.js";
import {
  T
} from "./chunk-6P7HXSJ6.js";
import "./chunk-LTDNORB5.js";
import "./chunk-HQLPC24M.js";
import "./chunk-H7PA52WJ.js";
import "./chunk-PODRVOXS.js";
import "./chunk-NALU24NB.js";
import "./chunk-REAPFM7O.js";
import "./chunk-UNGOQUF2.js";
import "./chunk-AIKBABBU.js";
import "./chunk-A42OBC4U.js";
import "./chunk-BDBI2KVA.js";
import {
  n
} from "./chunk-7AOPU62X.js";
import "./chunk-WE4EKKVR.js";
import "./chunk-UFBX3XSC.js";
import "./chunk-F7TCEOHX.js";
import "./chunk-5BULKNR2.js";
import "./chunk-RYSF6YCR.js";
import "./chunk-4LTV6KQ5.js";
import "./chunk-PPIAYGRE.js";
import "./chunk-L7T5Z7MG.js";
import "./chunk-WCGYJMU3.js";
import "./chunk-577U4F6A.js";
import "./chunk-HS4XAAAN.js";
import "./chunk-STW6HRXO.js";
import {
  r
} from "./chunk-7QTMSBS3.js";
import "./chunk-M6FNW7GP.js";
import "./chunk-5HI5HAKB.js";
import "./chunk-CWMZW2S5.js";
import "./chunk-2N2W26AY.js";
import "./chunk-JVWSFFO4.js";

// node_modules/@arcgis/core/libs/i3s/enums.js
var n5;
var e;
!function(n10) {
  n10[n10.None = 0] = "None", n10[n10.Int16 = 1] = "Int16", n10[n10.Int32 = 2] = "Int32";
}(n5 || (n5 = {})), function(n10) {
  n10[n10.Replace = 0] = "Replace", n10[n10.Outside = 1] = "Outside", n10[n10.Inside = 2] = "Inside", n10[n10.Finished = 3] = "Finished";
}(e || (e = {}));

// node_modules/@arcgis/core/libs/i3s/I3SModule.js
function e2() {
  return n6 || (n6 = new Promise((t) => import("./i3s-ONM5CED6.js").then((t2) => t2.i).then(({ default: e4 }) => {
    const n10 = e4({ locateFile: i, onRuntimeInitialized: () => t(n10) });
    delete n10.then;
  })).catch((t) => {
    throw t;
  })), n6;
}
function i(e4) {
  return n(`esri/libs/i3s/${e4}`);
}
var n6;

// node_modules/@arcgis/core/views/3d/layers/I3SMeshWorkerHandle.js
var n9 = class {
  constructor(s, e4, t, o2, r4, i2) {
    this.layout = s, this.interleavedVertexData = e4, this.indices = t, this.hasColors = o2, this.hasModifications = r4, this.positionData = i2;
  }
};
var p = class {
  constructor(s, e4, t, o2, r4, i2, h3) {
    this.componentOffsets = s, this.featureIds = e4, this.anchorIds = t, this.anchors = o2, this.transformedGeometry = r4, this.globalTrafo = i2, this.obb = h3;
  }
};
var u = new r({ deallocator: null });
var c = n2();

// node_modules/@arcgis/core/views/3d/layers/i3s/I3SNode.js
var o;
var r3;
var a2;
var d2;
var c2;
!function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.Culled = 1] = "Culled", e4[e4.NotChecked = 2] = "NotChecked";
}(o || (o = {})), function(e4) {
  e4[e4.Unmodified = 0] = "Unmodified", e4[e4.PotentiallyModified = 1] = "PotentiallyModified", e4[e4.Culled = 2] = "Culled", e4[e4.Unknown = 3] = "Unknown", e4[e4.NotChecked = 4] = "NotChecked";
}(r3 || (r3 = {}));
!function(e4) {
  e4[e4.Unknown = 0] = "Unknown", e4[e4.Uncached = 1] = "Uncached", e4[e4.Cached = 2] = "Cached";
}(a2 || (a2 = {})), function(e4) {
  e4[e4.None = 0] = "None", e4[e4.MaxScreenThreshold = 1] = "MaxScreenThreshold", e4[e4.ScreenSpaceRelative = 2] = "ScreenSpaceRelative", e4[e4.RemovedFeatureDiameter = 3] = "RemovedFeatureDiameter", e4[e4.DistanceRangeFromDefaultCamera = 4] = "DistanceRangeFromDefaultCamera";
}(d2 || (d2 = {})), function(e4) {
  e4[e4.Hole = 0] = "Hole", e4[e4.Leaf = 1] = "Leaf";
}(c2 || (c2 = {}));

// node_modules/@arcgis/core/views/3d/layers/SceneLayerWorker.js
async function u2(e4) {
  E = await M();
  const r4 = [e4.geometryBuffer];
  return { result: A(E, e4, r4), transferList: r4 };
}
async function m(e4) {
  var _a;
  E = await M();
  const r4 = [e4.geometryBuffer], { geometryBuffer: t } = e4, o2 = t.byteLength, n10 = E._malloc(o2), s = new Uint8Array(E.HEAPU8.buffer, n10, o2);
  s.set(new Uint8Array(t));
  const i2 = E.dracoDecompressPointCloudData(n10, s.byteLength);
  if (E._free(n10), i2.error.length > 0) throw new Error(`i3s.wasm: ${i2.error}`);
  const a3 = ((_a = i2.featureIds) == null ? void 0 : _a.length) > 0 ? i2.featureIds.slice() : null, f = i2.positions.slice();
  return a3 && r4.push(a3.buffer), r4.push(f.buffer), { result: { positions: f, featureIds: a3 }, transferList: r4 };
}
async function y(e4) {
  await M(), S(e4);
  const r4 = { buffer: e4.buffer };
  return { result: r4, transferList: [r4.buffer] };
}
async function p2(e4) {
  await M(), j(e4);
}
async function d3(e4) {
  E = await M(), E.setLegacySchema(e4.context, e4.jsonSchema);
}
async function h2(e4) {
  const { localMatrix: n10, origin: s, positions: i2, vertexSpace: a3 } = e4, f = g.fromJSON(e4.inSpatialReference), c3 = g.fromJSON(e4.outSpatialReference);
  let l;
  const [{ projectBuffer: u3 }, { initializeProjection: m2 }] = await Promise.all([import("./projectBuffer-E3IV2XUH.js"), import("./projection-JB4AVDSU.js")]);
  await m2(f, c3);
  const y2 = [0, 0, 0];
  if (!u3(s, f, 0, y2, c3, 0)) throw new Error("Failed to project");
  if ("georeferenced" === a3.type && null == a3.origin) {
    if (l = new Float64Array(i2.length), !u3(i2, f, 0, l, c3, 0, l.length / 3)) throw new Error("Failed to project");
  } else {
    const e5 = "georeferenced" === a3.type ? n3.fromJSON(a3) : a.fromJSON(a3), { projectMeshVertexPositions: r4 } = await import("./projectMeshVertexPositions-4WBADQ2B.js"), s2 = r4({ vertexAttributes: { position: i2 }, transform: n10 ? { localMatrix: n10 } : void 0, vertexSpace: e5, spatialReference: f }, c3);
    if (!s2) throw new Error("Failed to project");
    l = s2;
  }
  const p3 = l.length, [d4, h3, b2] = y2;
  for (let r4 = 0; r4 < p3; r4 += 3) l[r4] -= d4, l[r4 + 1] -= h3, l[r4 + 2] -= b2;
  return { result: { projected: l, original: i2, projectedOrigin: y2 }, transferList: [l.buffer, i2.buffer] };
}
async function b({ normalMatrix: r4, normals: t }) {
  const o2 = new Float32Array(t.length);
  return n4(o2, t, r4), T(r4) && d(o2, o2), { result: { transformed: o2, original: t }, transferList: [o2.buffer, t.buffer] };
}
function g2(e4) {
  x(e4);
}
var w;
var E;
function j(e4) {
  if (!E) return;
  const r4 = e4.modifications, t = E._malloc(8 * r4.length), o2 = new Float64Array(E.HEAPU8.buffer, t, r4.length);
  for (let n10 = 0; n10 < r4.length; ++n10) o2[n10] = r4[n10];
  E.setModifications(e4.context, t, r4.length, e4.isGeodetic), E._free(t);
}
function A(e4, r4, t) {
  const { context: o2, globalTrafo: n10, mbs: s, obbData: a3, elevationOffset: l, geometryBuffer: u3, geometryDescriptor: m2, indexToVertexProjector: y2, vertexToRenderProjector: p3 } = r4, d4 = e4._malloc(u3.byteLength), h3 = 33, b2 = e4._malloc(h3 * Float64Array.BYTES_PER_ELEMENT), g3 = new Uint8Array(e4.HEAPU8.buffer, d4, u3.byteLength);
  g3.set(new Uint8Array(u3));
  const w2 = new Float64Array(e4.HEAPU8.buffer, b2, h3);
  _(w2, [NaN, NaN, NaN]);
  let E2 = w2.byteOffset + 3 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2);
  _(j2, n10), E2 += 16 * w2.BYTES_PER_ELEMENT, j2 = new Float64Array(w2.buffer, E2), _(j2, s), E2 += 4 * w2.BYTES_PER_ELEMENT, a3 && (j2 = new Float64Array(w2.buffer, E2), _(j2, a3));
  const A2 = m2, L3 = { isDraco: false, isLegacy: false, color: r4.layouts.some((e5) => e5.some((e6) => "color" === e6.name)), normal: r4.needNormals && r4.layouts.some((e5) => e5.some((e6) => "normalCompressed" === e6.name)), uv0: r4.layouts.some((e5) => e5.some((e6) => "uv0" === e6.name)), uvRegion: r4.layouts.some((e5) => e5.some((e6) => "uvRegion" === e6.name)), featureIndex: A2.featureIndex }, S2 = e4.process(o2, !!r4.obbData, d4, g3.byteLength, A2, L3, b2, l, y2, p3, r4.normalReferenceFrame);
  if (e4._free(b2), e4._free(d4), S2.error.length > 0) throw new Error(`i3s.wasm: ${S2.error}`);
  if (S2.discarded) return null;
  const x2 = S2.componentOffsets.length > 0 ? S2.componentOffsets.slice() : null, P2 = S2.featureIds.length > 0 ? S2.featureIds.slice() : null, M2 = S2.anchorIds.length > 0 ? Array.from(S2.anchorIds) : null, N2 = S2.anchors.length > 0 ? Array.from(S2.anchors) : null, U = S2.interleavedVertedData.slice().buffer, I = S2.indicesType === n5.Int16 ? new Uint16Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 2).slice() : new Uint32Array(S2.indices.buffer, S2.indices.byteOffset, S2.indices.byteLength / 4).slice(), F = S2.positions.slice(), { buffer: T2, byteOffset: B, byteLength: O } = S2.positionIndices, R = S2.positionIndicesType === n5.Int16 ? new Uint16Array(T2, B, O / 2).slice() : new Uint32Array(T2, B, O / 4).slice(), v = new n9(r4.layouts[0], U, I, S2.hasColors, S2.hasModifications, { data: F, indices: R });
  return P2 && t.push(P2.buffer), x2 && t.push(x2.buffer), t.push(U), t.push(I.buffer), t.push(F.buffer), t.push(R.buffer), new p(x2, P2, M2, N2, v, n10, S2.obb);
}
function L2(e4) {
  return 0 === e4 ? r3.Unmodified : 1 === e4 ? r3.PotentiallyModified : 2 === e4 ? r3.Culled : r3.Unknown;
}
function S(e4) {
  if (!E) return;
  const { context: r4, buffer: t } = e4, o2 = E._malloc(t.byteLength), n10 = t.byteLength / Float64Array.BYTES_PER_ELEMENT, s = new Float64Array(E.HEAPU8.buffer, o2, n10), i2 = new Float64Array(t);
  s.set(i2), E.filterOBBs(r4, o2, n10), i2.set(s), E._free(o2);
}
function x(e4) {
  E && 0 === E.destroy(e4) && (E = null);
}
function _(e4, r4) {
  for (let t = 0; t < r4.length; ++t) e4[t] = r4[t];
}
async function P() {
  E || await M();
}
async function M() {
  return E || (E = await (w ?? (w = e2()))), E;
}
var N = { transform: (e4, r4) => E && A(E, e4, r4), destroy: x };
export {
  g2 as destroyContext,
  m as dracoDecompressPointCloudData,
  y as filterObbsForModifications,
  S as filterObbsForModificationsSync,
  P as initialize,
  L2 as interpretObbModificationResults,
  u2 as process,
  h2 as project,
  d3 as setLegacySchema,
  p2 as setModifications,
  j as setModificationsSync,
  N as test,
  b as transformNormals
};
//# sourceMappingURL=SceneLayerWorker-WLYXE3R7.js.map
