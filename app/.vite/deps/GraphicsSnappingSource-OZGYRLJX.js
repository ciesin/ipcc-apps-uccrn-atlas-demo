import {
  i as i2,
  o
} from "./chunk-LHGTWVNO.js";
import "./chunk-DVLQPRGL.js";
import "./chunk-QGVT5UOI.js";
import "./chunk-647JB2RE.js";
import {
  t
} from "./chunk-2UBP7L6V.js";
import "./chunk-4BTKBTXL.js";
import "./chunk-ABH42FPX.js";
import {
  E,
  y as y4
} from "./chunk-FAAI5VMG.js";
import "./chunk-6MN3R543.js";
import "./chunk-TY5FDDRF.js";
import "./chunk-NJTJZUTI.js";
import {
  i,
  n,
  r as r2
} from "./chunk-B77SQDEC.js";
import {
  u
} from "./chunk-WD2I76P3.js";
import {
  a as a2
} from "./chunk-LTPPCHKR.js";
import {
  f
} from "./chunk-BFWSC7OC.js";
import "./chunk-OLVQKB2U.js";
import {
  L as L2
} from "./chunk-MYUL4ERJ.js";
import "./chunk-CEFHUHE4.js";
import "./chunk-RDJPXK25.js";
import "./chunk-QPYSCM2R.js";
import "./chunk-4JTNLE52.js";
import "./chunk-2N6IIYX4.js";
import {
  N
} from "./chunk-M6YQSYSW.js";
import "./chunk-4FQK362J.js";
import "./chunk-NQPBPVRE.js";
import {
  y as y3
} from "./chunk-PFFYYIYN.js";
import "./chunk-WAKNRSGF.js";
import "./chunk-NATJDMSF.js";
import "./chunk-HY3PTUEL.js";
import "./chunk-5YAYVSAD.js";
import {
  st
} from "./chunk-F7TFMQ3A.js";
import "./chunk-YRSM2W7P.js";
import {
  s as s2
} from "./chunk-EM6PL3GZ.js";
import "./chunk-J7454WTE.js";
import "./chunk-FKPHHMJX.js";
import "./chunk-U6JFTJMZ.js";
import "./chunk-GNFRPKN6.js";
import "./chunk-6X7CIA5N.js";
import "./chunk-U4VVTGEX.js";
import "./chunk-NVEHOQKI.js";
import "./chunk-NOMJWA3C.js";
import "./chunk-X5RZJMNW.js";
import "./chunk-K24WU5UX.js";
import "./chunk-GTAKWPJC.js";
import "./chunk-A4LAIXK6.js";
import "./chunk-FF7WZBMV.js";
import "./chunk-CBVVZO37.js";
import "./chunk-Z2A222O3.js";
import "./chunk-3WMBBCKF.js";
import "./chunk-5DJJ57UM.js";
import {
  h as h2
} from "./chunk-PV4EUSKO.js";
import {
  g as g3
} from "./chunk-DH57DJ4C.js";
import "./chunk-C4KYMV6K.js";
import "./chunk-5BWPRODD.js";
import "./chunk-O2L6JAHP.js";
import "./chunk-LH36NQSN.js";
import "./chunk-K35H6D4D.js";
import "./chunk-UMYFDXOJ.js";
import "./chunk-67XXGAOA.js";
import "./chunk-4TZUFQZG.js";
import "./chunk-HLOKDQU3.js";
import "./chunk-RAXTPGM6.js";
import {
  Z
} from "./chunk-FFVHLGAP.js";
import "./chunk-YLPB3XO6.js";
import "./chunk-BTTTF5H4.js";
import "./chunk-MEC6IDRX.js";
import "./chunk-ZH6PYRVF.js";
import "./chunk-MHM4GDCM.js";
import "./chunk-363AT5UF.js";
import "./chunk-TOMXDOXB.js";
import "./chunk-VTPZW6H5.js";
import "./chunk-KWOLBNIK.js";
import "./chunk-TGMFGDP6.js";
import "./chunk-JST5QDP2.js";
import "./chunk-A4BGGF5Z.js";
import "./chunk-D3HK4ZSW.js";
import "./chunk-AI2O2GKK.js";
import "./chunk-ANGUSND2.js";
import "./chunk-WF2ACUGU.js";
import "./chunk-4NGIUHKX.js";
import "./chunk-FF44HCOD.js";
import "./chunk-AVY6RZDG.js";
import "./chunk-JJAT7JGD.js";
import "./chunk-D4CSBMND.js";
import "./chunk-IPFYNOOY.js";
import "./chunk-PUC7IJYJ.js";
import "./chunk-ESU5C3MV.js";
import "./chunk-TYJOGWKZ.js";
import "./chunk-4WO6KUCB.js";
import "./chunk-2Y4TRKRB.js";
import "./chunk-XEBZUAYT.js";
import {
  L,
  O,
  Q
} from "./chunk-4WERUJEK.js";
import "./chunk-YFLBSX2D.js";
import "./chunk-6REABBOQ.js";
import "./chunk-STBNLAGT.js";
import "./chunk-HSI6V34N.js";
import "./chunk-QTWG47SG.js";
import "./chunk-WJGG35K6.js";
import "./chunk-ZDVQNOKR.js";
import "./chunk-Y3AY7I5U.js";
import "./chunk-SUVHJC6Z.js";
import "./chunk-WJNMFEXQ.js";
import {
  y as y2
} from "./chunk-XCRRZPKE.js";
import "./chunk-WZBMMIVS.js";
import "./chunk-WLGGSXQY.js";
import {
  j
} from "./chunk-T7KGE6VP.js";
import "./chunk-T57WVICI.js";
import "./chunk-W633AKTD.js";
import "./chunk-UCMTPLHQ.js";
import "./chunk-G34KEQQG.js";
import "./chunk-AZ33ECVF.js";
import "./chunk-FENCNBXD.js";
import "./chunk-3UHB6K6P.js";
import "./chunk-ZYOZHQFS.js";
import "./chunk-MLOZK7WX.js";
import "./chunk-FIBMMWXR.js";
import "./chunk-53ZTROGC.js";
import "./chunk-PUM22WTC.js";
import "./chunk-K2PILHWE.js";
import "./chunk-JLFV7EBO.js";
import "./chunk-BV7O6P7Z.js";
import "./chunk-JLFSX3JT.js";
import "./chunk-PAGKMWJH.js";
import "./chunk-CHL75CEP.js";
import "./chunk-SQ6MYL73.js";
import "./chunk-HP7OWCUK.js";
import "./chunk-NENDDUWH.js";
import "./chunk-YUVX6H42.js";
import "./chunk-5ESATYIQ.js";
import "./chunk-RDUV6YP6.js";
import "./chunk-6P7HXSJ6.js";
import "./chunk-LTDNORB5.js";
import "./chunk-HQLPC24M.js";
import "./chunk-NALU24NB.js";
import "./chunk-REAPFM7O.js";
import "./chunk-UNGOQUF2.js";
import {
  P,
  d as d2,
  v
} from "./chunk-YSPSOPLL.js";
import "./chunk-AJSC5XSW.js";
import "./chunk-I4HN3ELT.js";
import {
  d
} from "./chunk-ACGZOBZ6.js";
import "./chunk-7LY6RE4Z.js";
import "./chunk-AIKBABBU.js";
import "./chunk-A42OBC4U.js";
import "./chunk-BDBI2KVA.js";
import "./chunk-7AOPU62X.js";
import "./chunk-WE4EKKVR.js";
import "./chunk-UFBX3XSC.js";
import "./chunk-F7TCEOHX.js";
import "./chunk-5BULKNR2.js";
import {
  g as g2,
  m
} from "./chunk-RYSF6YCR.js";
import {
  a3 as a
} from "./chunk-4LTV6KQ5.js";
import {
  r
} from "./chunk-PPIAYGRE.js";
import "./chunk-L7T5Z7MG.js";
import "./chunk-WCGYJMU3.js";
import "./chunk-577U4F6A.js";
import "./chunk-HS4XAAAN.js";
import "./chunk-STW6HRXO.js";
import "./chunk-7QTMSBS3.js";
import {
  g,
  h,
  s
} from "./chunk-M6FNW7GP.js";
import "./chunk-5HI5HAKB.js";
import "./chunk-CWMZW2S5.js";
import {
  y
} from "./chunk-2N2W26AY.js";
import "./chunk-JVWSFFO4.js";

// node_modules/@arcgis/core/views/interactive/snapping/featureSources/GraphicsSnappingSource.js
var O2 = "graphics-collections";
var U = class extends g2 {
  get updating() {
    return this._updatingHandles.updating;
  }
  get _hasZ() {
    const e = this.view;
    return null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
  }
  get _snappingElevationAligner() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type;
    if (!o2 || "map-notes" === t2.type) return i();
    const s3 = async (o3, s4) => (await h(e.whenLayerView(t2), s4)).elevationAlignPointsInFeatures(o3, s4);
    return i(o2, { elevationInfo: t2.elevationInfo, alignPointsInFeatures: s3 });
  }
  get _snappingElevationFilter() {
    const { view: e } = this, t2 = null != e && "3d" === e.type && "map-notes" !== this.layerSource.layer.type;
    return r2(t2);
  }
  get _symbologySnappingFetcher() {
    const { view: e } = this, { layer: t2 } = this.layerSource, o2 = null != e && "3d" === e.type, s3 = this._extrudedPolygonSymbolsCount > 0;
    return o2 && "map-notes" !== t2.type && s3 ? n(s3, async (o3, s4) => {
      const r3 = await e.whenLayerView(t2);
      return s(s4), r3.queryForSymbologySnapping({ candidates: o3, spatialReference: e.spatialReference }, s4);
    }) : n();
  }
  constructor(e) {
    super(e), this.availability = 1, this._sources = { multipoint: null, point: null, polygon: null, polyline: null }, this._loadedWkids = /* @__PURE__ */ new Set(), this._loadedWkts = /* @__PURE__ */ new Set(), this._pendingAdds = [], this._extrudedPolygonSymbolsCount = 0, this._updatingHandles = new h2(), this._memoizedMakeGetGroundElevation = t(i2);
  }
  destroy() {
    for (const e of this._pendingAdds) e.task.abort();
    this._pendingAdds.length = 0, this._mapSources((e) => this._destroySource(e)), this._updatingHandles.destroy();
  }
  initialize() {
    this._updatingHandles.add(() => this.getGraphicsLayers(), (e2) => {
      this._updatingHandles.removeHandles(O2);
      for (const t3 of e2) this._addMany(t3.graphics.toArray()), this.addHandles([t3.on("graphic-update", (e3) => this._onGraphicUpdate(e3)), this._updatingHandles.addOnCollectionChange(() => t3.graphics, (e3) => this._onGraphicsChanged(e3))], O2);
    }, P);
    const { view: e } = this, { layer: t2 } = this.layerSource;
    null != e && "3d" === e.type && "map-notes" !== t2.type && e.elevationProvider && this.addHandles([e.elevationProvider.on("elevation-change", ({ context: e2 }) => {
      y3(e2, t2.elevationInfo) && this._snappingElevationAligner.notifyElevationSourceChange();
    }), d2(() => t2.elevationInfo, () => this._snappingElevationAligner.notifyElevationSourceChange(), P), v(() => t2, ["edits", "apply-edits", "graphic-update"], () => this._symbologySnappingFetcher.notifySymbologyChange())]);
  }
  async fetchCandidates(e, t2) {
    const { point: o2, coordinateHelper: { spatialReference: s3 } } = e, r3 = await g(this._mapSources((o3) => this._fetchCandidatesForSource(o3, e, t2)));
    s(t2);
    const a3 = this._memoizedMakeGetGroundElevation(this.view, s3), p = r3.flat().map((e2) => o(e2, a3));
    return E(o2, p), p;
  }
  async _fetchCandidatesForSource(e, t2, o2) {
    var _a;
    const s3 = y4(t2, ((_a = this.view) == null ? void 0 : _a.type) ?? "2d"), r3 = await u(e.queryEngine, s3, o2);
    s(o2);
    const i3 = await this._snappingElevationAligner.alignCandidates(r3.candidates, t2.coordinateHelper.spatialReference, o2);
    s(o2);
    const a3 = await this._symbologySnappingFetcher.fetch(i3, o2);
    s(o2);
    const p = 0 === a3.length ? i3 : [...i3, ...a3];
    return this._snappingElevationFilter.filter(s3, p);
  }
  refresh() {
  }
  _onGraphicUpdate(e) {
    if (this.getGraphicsLayers().some((t2) => t2.graphics.includes(e.graphic))) switch (e.property) {
      case "geometry":
      case "visible":
        this._remove(e.graphic), this._addMany([e.graphic]);
    }
  }
  _onGraphicsChanged(e) {
    for (const t2 of e.removed) this._remove(t2);
    this._addMany(e.added);
  }
  _addMany(e) {
    const t2 = [], o2 = /* @__PURE__ */ new Map();
    for (const s3 of e) null != s3.geometry && (this._needsInitializeProjection(s3.geometry.spatialReference) ? (t2.push(s3.geometry.spatialReference), o2.set(s3.uid, s3)) : this._add(s3));
    this._createPendingAdd(t2, o2);
  }
  _createPendingAdd(e, t2) {
    if (!e.length) return;
    const r3 = d(async (o2) => {
      await Q(e.map((e2) => ({ source: e2, dest: this.spatialReference })), { signal: o2 }), this._markLoadedSpatialReferences(e);
      for (const e2 of t2.values()) this._add(e2);
    });
    this._updatingHandles.addPromise(r3.promise);
    const i3 = { task: r3, graphics: t2 }, n2 = () => y(this._pendingAdds, i3);
    r3.promise.then(n2, n2), this._pendingAdds.push(i3);
  }
  _markLoadedSpatialReferences(e) {
    for (const t2 of e) {
      null != t2.wkid && this._loadedWkids.add(t2.wkid);
      const e2 = t2.wkt2 || t2.wkt;
      e2 && this._loadedWkts.add(e2);
    }
  }
  _add(e) {
    if (null == e.geometry || !e.visible) return;
    let t2 = e.geometry;
    if ("mesh" === t2.type) return;
    "extent" === t2.type && (t2 = j.fromExtent(t2));
    const o2 = this._ensureSource(t2.type);
    if (null == o2) return;
    const s3 = this._createOptimizedFeature(e.uid, t2);
    null != s3 && (o2.featureStore.add(s3), N(e.symbol) && this._extrudedPolygonSymbolsCount++);
  }
  _needsInitializeProjection(e) {
    if (null != e.wkid && this._loadedWkids.has(e.wkid)) return false;
    const t2 = e.wkt2 || e.wkt;
    return (!t2 || !this._loadedWkts.has(t2)) && !L(e, this.spatialReference);
  }
  _createOptimizedFeature(e, t2) {
    const o2 = O(a2(t2), this.spatialReference);
    if (!o2) return null;
    const s3 = this._ensureGeometryHasZ(o2), r3 = st(s3, this._hasZ, false);
    return new s2(r3, { [Z2]: e }, null, e);
  }
  _ensureGeometryHasZ(e) {
    if (!this._hasZ) return e;
    const t2 = (e2) => {
      for (; e2.length < 3; ) e2.push(0);
    }, o2 = e.clone();
    switch (o2.hasZ = true, o2.type) {
      case "point":
        o2.z = o2.z ?? 0;
        break;
      case "multipoint":
        o2.points.forEach(t2);
        break;
      case "polyline":
        o2.paths.forEach((e2) => e2.forEach(t2));
        break;
      case "polygon":
        o2.rings.forEach((e2) => e2.forEach(t2));
    }
    return o2;
  }
  _ensureSource(e) {
    const t2 = this._sources[e];
    if (null != t2) return t2;
    const o2 = this._createSource(e);
    return this._sources[e] = o2, o2;
  }
  _createSource(e) {
    const t2 = y2.toJSON(e), o2 = this._hasZ, s3 = new f({ geometryType: t2, hasZ: o2, hasM: false });
    return { featureStore: s3, queryEngine: new L2({ featureStore: s3, fieldsIndex: Z.fromLayerJSON({ fields: [{ name: Z2, type: "esriFieldTypeOID", alias: Z2 }] }), geometryType: t2, hasM: false, hasZ: o2, objectIdField: Z2, spatialReference: this.spatialReference, priority: g3.SNAPPING, scheduler: null != this.view && "3d" === this.view.type ? this.view.resourceController.scheduler : null }), type: e };
  }
  _remove(e) {
    this._mapSources((t2) => this._removeFromSource(t2, e));
    for (const t2 of this._pendingAdds) t2.graphics.delete(e.uid), 0 === t2.graphics.size && t2.task.abort();
  }
  _removeFromSource(e, t2) {
    const o2 = t2.uid;
    e.featureStore.has(o2) && (e.featureStore.removeById(t2.uid), N(t2.symbol) && this._extrudedPolygonSymbolsCount--);
  }
  _destroySource(e) {
    e.queryEngine.destroy(), this._sources[e.type] = null;
  }
  _mapSources(e) {
    const { point: t2, polygon: o2, polyline: s3, multipoint: r3 } = this._sources, i3 = [];
    return null != t2 && i3.push(e(t2)), null != o2 && i3.push(e(o2)), null != s3 && i3.push(e(s3)), null != r3 && i3.push(e(r3)), i3;
  }
};
r([m()], U.prototype, "getGraphicsLayers", void 0), r([m({ constructOnly: true })], U.prototype, "layerSource", void 0), r([m({ constructOnly: true })], U.prototype, "spatialReference", void 0), r([m({ constructOnly: true })], U.prototype, "view", void 0), r([m({ readOnly: true })], U.prototype, "updating", null), r([m({ readOnly: true })], U.prototype, "availability", void 0), r([m()], U.prototype, "_hasZ", null), r([m()], U.prototype, "_snappingElevationAligner", null), r([m()], U.prototype, "_snappingElevationFilter", null), r([m()], U.prototype, "_symbologySnappingFetcher", null), r([m()], U.prototype, "_extrudedPolygonSymbolsCount", void 0), U = r([a("esri.views.interactive.snapping.featureSources.GraphicsSnappingSource")], U);
var Z2 = "OBJECTID";
export {
  U as GraphicsSnappingSource
};
//# sourceMappingURL=GraphicsSnappingSource-OZGYRLJX.js.map
