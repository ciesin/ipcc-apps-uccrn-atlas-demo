import {
  l
} from "./chunk-OQ3YQLHO.js";
import {
  l as l2
} from "./chunk-KAAAN25B.js";
import {
  t as t2
} from "./chunk-SMPH4DRM.js";
import {
  B as B2,
  E,
  F,
  L,
  N,
  R,
  R2,
  a as a2,
  a2 as a3,
  b as b2,
  c,
  e as e2,
  j,
  k,
  p,
  q as q2
} from "./chunk-BB7SPPCM.js";
import {
  O,
  u
} from "./chunk-N5NRCY3G.js";
import "./chunk-4DEIS6AK.js";
import {
  D as D2
} from "./chunk-7SWL6AYJ.js";
import "./chunk-PE5QC36M.js";
import {
  C
} from "./chunk-GKX3Z6XX.js";
import {
  B,
  Be,
  G,
  H,
  Ne,
  P,
  Q,
  Ze,
  _e,
  be,
  ee,
  ne,
  oe,
  q,
  re,
  te,
  ye
} from "./chunk-O4H354HZ.js";
import {
  s,
  x
} from "./chunk-SCYMP6Y5.js";
import {
  t
} from "./chunk-TSDU5FXE.js";
import "./chunk-JMVIOIWP.js";
import {
  p as p3
} from "./chunk-XUSH2QIE.js";
import "./chunk-QWAJYOS6.js";
import {
  a as a4
} from "./chunk-PC54C6NQ.js";
import "./chunk-F7TFMQ3A.js";
import "./chunk-YRSM2W7P.js";
import "./chunk-EM6PL3GZ.js";
import "./chunk-J7454WTE.js";
import "./chunk-U6JFTJMZ.js";
import {
  a,
  r as r2
} from "./chunk-TA6O62P3.js";
import {
  D
} from "./chunk-CBVVZO37.js";
import "./chunk-Z2A222O3.js";
import "./chunk-6MP23PR5.js";
import {
  p as p2
} from "./chunk-CXW7QK2T.js";
import {
  Ye
} from "./chunk-JT5MNXX3.js";
import "./chunk-PEVRDPML.js";
import "./chunk-4KVDFBS3.js";
import "./chunk-7FHK22OY.js";
import "./chunk-HWGSEVKH.js";
import "./chunk-4LAB32KQ.js";
import "./chunk-JOUVYFAY.js";
import "./chunk-44OKV7LZ.js";
import "./chunk-R5QEGUQL.js";
import "./chunk-6WVUJOLD.js";
import "./chunk-YQHLNRT3.js";
import "./chunk-G7HNCC5G.js";
import "./chunk-QLSJI3DL.js";
import "./chunk-3VG7BBW5.js";
import "./chunk-ZWAL4BY6.js";
import "./chunk-KS56T55N.js";
import "./chunk-FK3WBTHH.js";
import "./chunk-TGJTL3DX.js";
import "./chunk-ZROOJR26.js";
import "./chunk-27HW4PAJ.js";
import "./chunk-VL6ABOSV.js";
import "./chunk-2KG6WO5I.js";
import "./chunk-D4RMC5GM.js";
import "./chunk-BWQFRI3E.js";
import "./chunk-F23MXZYK.js";
import "./chunk-LZTCFOLV.js";
import "./chunk-J6MQFQDT.js";
import "./chunk-RAXTPGM6.js";
import "./chunk-FFVHLGAP.js";
import "./chunk-GCLTWKVB.js";
import "./chunk-LVOCICBG.js";
import "./chunk-TNYXYQXK.js";
import "./chunk-WANI2G7M.js";
import "./chunk-2O2K2GAF.js";
import "./chunk-LJBNLWJN.js";
import "./chunk-RKXU25GZ.js";
import "./chunk-3GIIPEHS.js";
import "./chunk-SCNACYSF.js";
import "./chunk-Q7YUVHCX.js";
import "./chunk-MG7UOFLP.js";
import "./chunk-ACXFIEER.js";
import "./chunk-PXJIE4N5.js";
import "./chunk-5LA23O74.js";
import "./chunk-4A3WH4AR.js";
import "./chunk-4KREATVZ.js";
import "./chunk-YLPB3XO6.js";
import "./chunk-DMXES2BK.js";
import "./chunk-ONZPKEDE.js";
import "./chunk-BTTTF5H4.js";
import "./chunk-MEC6IDRX.js";
import "./chunk-ZH6PYRVF.js";
import "./chunk-MHM4GDCM.js";
import "./chunk-363AT5UF.js";
import "./chunk-CQ2PC3VP.js";
import "./chunk-XUYUNZTH.js";
import "./chunk-HCXUWF52.js";
import "./chunk-ZCYDEY6S.js";
import "./chunk-POMCHIIZ.js";
import "./chunk-5GAOP2C3.js";
import "./chunk-6WASKRTP.js";
import "./chunk-37HZDVD7.js";
import "./chunk-3S47CK7X.js";
import "./chunk-7FOAM45I.js";
import "./chunk-EMADK6RJ.js";
import "./chunk-VY225BNN.js";
import "./chunk-FBQYHS7L.js";
import "./chunk-LGG5FPVD.js";
import "./chunk-TOMXDOXB.js";
import "./chunk-VTPZW6H5.js";
import "./chunk-DWXK7D3B.js";
import "./chunk-EW3YCVZI.js";
import "./chunk-WZ7EFR6C.js";
import "./chunk-CVABZLLM.js";
import "./chunk-DDEXP7LW.js";
import "./chunk-KWOLBNIK.js";
import "./chunk-JLW377TH.js";
import "./chunk-TGMFGDP6.js";
import "./chunk-JST5QDP2.js";
import "./chunk-A4BGGF5Z.js";
import "./chunk-QM4DRRZI.js";
import "./chunk-LPMFP5XM.js";
import "./chunk-775V3L2A.js";
import "./chunk-AI2O2GKK.js";
import "./chunk-ANGUSND2.js";
import "./chunk-WF2ACUGU.js";
import "./chunk-4NGIUHKX.js";
import {
  y
} from "./chunk-FF44HCOD.js";
import "./chunk-AVY6RZDG.js";
import "./chunk-D4CSBMND.js";
import {
  b
} from "./chunk-5X74MKXM.js";
import "./chunk-LCBD3JEK.js";
import "./chunk-IPFYNOOY.js";
import "./chunk-PUC7IJYJ.js";
import "./chunk-ESU5C3MV.js";
import "./chunk-TYJOGWKZ.js";
import "./chunk-4WO6KUCB.js";
import "./chunk-2Y4TRKRB.js";
import "./chunk-XEBZUAYT.js";
import "./chunk-4WERUJEK.js";
import "./chunk-YFLBSX2D.js";
import "./chunk-6REABBOQ.js";
import "./chunk-STBNLAGT.js";
import "./chunk-HSI6V34N.js";
import "./chunk-QTWG47SG.js";
import "./chunk-WJGG35K6.js";
import {
  e,
  o,
  r
} from "./chunk-ZDVQNOKR.js";
import {
  m
} from "./chunk-Y3AY7I5U.js";
import "./chunk-SUVHJC6Z.js";
import "./chunk-WJNMFEXQ.js";
import "./chunk-XCRRZPKE.js";
import "./chunk-WZBMMIVS.js";
import "./chunk-WLGGSXQY.js";
import "./chunk-T7KGE6VP.js";
import "./chunk-T57WVICI.js";
import "./chunk-W633AKTD.js";
import "./chunk-UCMTPLHQ.js";
import "./chunk-G34KEQQG.js";
import "./chunk-5EWD56QJ.js";
import "./chunk-3UHB6K6P.js";
import "./chunk-ZYOZHQFS.js";
import "./chunk-MLOZK7WX.js";
import "./chunk-XWXWIBVO.js";
import "./chunk-NTUX5M6N.js";
import "./chunk-FIBMMWXR.js";
import "./chunk-53ZTROGC.js";
import "./chunk-PUM22WTC.js";
import "./chunk-K2PILHWE.js";
import "./chunk-JLFV7EBO.js";
import "./chunk-BV7O6P7Z.js";
import "./chunk-JLFSX3JT.js";
import "./chunk-IP4HFFRO.js";
import {
  C as C2
} from "./chunk-PAGKMWJH.js";
import "./chunk-CHL75CEP.js";
import "./chunk-SQ6MYL73.js";
import "./chunk-HP7OWCUK.js";
import "./chunk-SWBNCJYN.js";
import "./chunk-NENDDUWH.js";
import "./chunk-YUVX6H42.js";
import "./chunk-5ESATYIQ.js";
import "./chunk-RDUV6YP6.js";
import "./chunk-6P7HXSJ6.js";
import "./chunk-LTDNORB5.js";
import "./chunk-HQLPC24M.js";
import "./chunk-H7PA52WJ.js";
import "./chunk-PODRVOXS.js";
import "./chunk-NALU24NB.js";
import "./chunk-REAPFM7O.js";
import "./chunk-UNGOQUF2.js";
import "./chunk-YSPSOPLL.js";
import "./chunk-AJSC5XSW.js";
import "./chunk-I4HN3ELT.js";
import "./chunk-ACGZOBZ6.js";
import "./chunk-7LY6RE4Z.js";
import "./chunk-AIKBABBU.js";
import "./chunk-A42OBC4U.js";
import "./chunk-BDBI2KVA.js";
import "./chunk-7AOPU62X.js";
import "./chunk-WE4EKKVR.js";
import "./chunk-UFBX3XSC.js";
import "./chunk-F7TCEOHX.js";
import "./chunk-5BULKNR2.js";
import "./chunk-RYSF6YCR.js";
import "./chunk-4LTV6KQ5.js";
import "./chunk-PPIAYGRE.js";
import "./chunk-L7T5Z7MG.js";
import "./chunk-WCGYJMU3.js";
import "./chunk-577U4F6A.js";
import "./chunk-HS4XAAAN.js";
import "./chunk-STW6HRXO.js";
import "./chunk-7QTMSBS3.js";
import {
  S
} from "./chunk-M6FNW7GP.js";
import "./chunk-5HI5HAKB.js";
import "./chunk-CWMZW2S5.js";
import "./chunk-2N2W26AY.js";
import "./chunk-JVWSFFO4.js";

// node_modules/@arcgis/core/arcade/functions/featuresetbase.js
function ae(e3) {
  if (1 === e3.length) {
    if (o(e3[0])) return l("distinct", e3[0], -1);
    if (ee(e3[0])) return l("distinct", e3[0].toArray(), -1);
  }
  return l("distinct", e3, -1);
}
function re2(e3, t3, n) {
  const i = e3.getVariables();
  if (i.length > 0) {
    const a5 = {};
    for (const e4 of i) a5[e4] = t3.evaluateIdentifier(n, { name: e4 });
    e3.parameters = a5;
  }
  return e3;
}
function oe2(e3, t3, n = null) {
  for (const i in e3) if (i.toLowerCase() === t3.toLowerCase()) return e3[i];
  return n;
}
function se(e3) {
  if (null === e3) return null;
  const t3 = { type: oe2(e3, "type", ""), name: oe2(e3, "name", "") };
  if ("range" === t3.type) t3.range = oe2(e3, "range", []);
  else {
    t3.codedValues = [];
    for (const n of oe2(e3, "codedValues", [])) t3.codedValues.push({ name: oe2(n, "name", ""), code: oe2(n, "code", null) });
  }
  return t3;
}
function le(e3) {
  if (null === e3) return null;
  const t3 = {}, n = oe2(e3, "wkt");
  null !== n && (t3.wkt = n);
  const i = oe2(e3, "wkid");
  return null !== i && (t3.wkid = i), t3;
}
function fe(e3) {
  if (null === e3) return null;
  const t3 = { hasZ: oe2(e3, "hasz", false), hasM: oe2(e3, "hasm", false) }, n = oe2(e3, "spatialreference");
  null != n && (t3.spatialReference = le(n));
  const i = oe2(e3, "x", null);
  if (null !== i) return t3.x = i, t3.y = oe2(e3, "y", null), t3.hasZ && (t3.z = oe2(e3, "z", null)), t3.hasM && (t3.m = oe2(e3, "m", null)), t3;
  const a5 = oe2(e3, "rings", null);
  if (null !== a5) return t3.rings = a5, t3;
  const r3 = oe2(e3, "paths", null);
  if (null !== r3) return t3.paths = r3, t3;
  const o2 = oe2(e3, "points", null);
  if (null !== o2) return t3.points = o2, t3;
  for (const s2 of ["xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "mmin", "mmax"]) {
    const n2 = oe2(e3, s2, null);
    null !== n2 && (t3[s2] = n2);
  }
  return t3;
}
function de(e3, t3) {
  for (const n of t3) if (n === e3) return true;
  return false;
}
function ue(e3) {
  return !!e3.layerDefinition && (!!e3.featureSet && (false !== de(e3.layerDefinition.geometryType, ["", null, "esriGeometryNull", "esriGeometryPoint", "esriGeometryPolyline", "esriGeometryPolygon", "esriGeometryMultipoint", "esriGeometryEnvelope"]) && (false !== o(e3.layerDefinition.fields) && false !== o(e3.featureSet.features))));
}
function ce(e3) {
  return "utc" === (e3 == null ? void 0 : e3.toLowerCase()) ? "UTC" : "unknown" === (e3 == null ? void 0 : e3.toLowerCase()) ? "Unknown" : e3;
}
async function me(t3, n, i, o2, s2, l3, d) {
  var _a, _b, _c;
  const u2 = await t3.getFeatureSetInfo();
  if (null === ((u2 == null ? void 0 : u2.layerId) ?? null)) return null;
  if (!s2.layerIdLookup.get(u2.layerId)) return null;
  const c2 = t3.serviceUrl().replace(/\/FeatureServer/i, "/UtilityNetworkServer"), m2 = [];
  switch (i) {
    case "connected":
      m2.push("connectivity"), m2.push("junction-edge-from-connectivity"), m2.push("junction-edge-to-connectivity"), m2.push("junction-edge-midspan-connectivity"), m2.push("junction-junction-connectivity");
      break;
    case "container":
    case "content":
      m2.push("containment");
      break;
    case "structure":
    case "attached":
      m2.push("attachment");
      break;
    case "junctionedge":
      m2.push("junction-edge-from-connectivity"), m2.push("junction-edge-to-connectivity");
      break;
    case "midspan":
      m2.push("junction-edge-midspan-connectivity");
      break;
    default:
      throw new a(l3, r2.InvalidParameter, d);
  }
  let p4 = null, y2 = false;
  if (null !== o2 && "" !== o2 && void 0 !== o2) {
    for (const e3 of s2.terminals) e3.terminalName === o2 && (p4 = e3.terminalId);
    null === p4 && (y2 = true);
  }
  const w = [];
  if (!y2) {
    const a5 = new p2({ globalId: n.field(t3.globalIdField), networkSourceId: s2.layerIdLookup.get(u2.layerId).sourceId, ...p4 ? { terminalId: p4 } : "" }), r3 = await p3(c2, new a4({ types: m2, elements: [a5] }));
    let o3 = 0;
    for (const t4 of r3.associations) {
      let n2 = null, r4 = "", l4 = "";
      if (((_a = t4.fromNetworkElement) == null ? void 0 : _a.globalId) === a5.globalId ? (n2 = t4.toNetworkElement, l4 = "to") : ((_b = t4.toNetworkElement) == null ? void 0 : _b.globalId) === a5.globalId && (n2 = t4.fromNetworkElement, l4 = "from"), !n2) continue;
      switch (i) {
        case "attached":
          if ("attachment" !== t4.associationType) continue;
          if ("to" !== l4) continue;
          break;
        case "structure":
          if ("attachment" !== t4.associationType) continue;
          if ("from" !== l4) continue;
          break;
        case "container":
          if ("containment" !== t4.associationType) continue;
          if ("from" !== l4) continue;
          break;
        case "content":
          if ("containment" !== t4.associationType) continue;
          if ("to" !== l4) continue;
          break;
        case "connected":
          break;
        case "junctionedge":
          "junction-edge-to-connectivity" === t4.associationType ? r4 = "to" : "junction-edge-from-connectivity" === t4.associationType && (r4 = "from");
          break;
        case "midspan":
          if ("junction-edge-midspan-connectivity" !== t4.associationType) continue;
      }
      const f = ((_c = s2.sourceIdLookup.get(n2.networkSourceId)) == null ? void 0 : _c.className) ?? "";
      w.push(new b({ geometry: null, attributes: { objectId: o3++, globalId: n2.globalId, percentAlong: t4.percentAlong ?? 0, isContentVisible: t4.isContentVisible ? 0 : 1, className: f, side: r4 } }));
    }
  }
  const h = new Ye({ source: w, geometryType: null, objectIdField: "objectId", globalIdField: "globalId", fields: [new y({ name: "objectId", alias: "objectId", type: "oid" }), new y({ name: "globalId", alias: "globalId", type: "global-id" }), new y({ name: "percentAlong", alias: "percentAlong", type: "double" }), new y({ name: "side", alias: "side", type: "string" }), new y({ name: "isContentVisible", alias: "isContentVisible", type: "integer" }), new y({ name: "className", alias: "className", type: "string" })] });
  return N(h);
}
function pe(e3) {
  "async" === e3.mode && (e3.functions.timezone = function(n, o2) {
    return e3.standardFunctionAsync(n, o2, async (e4, s2, l3) => {
      var _a, _b;
      if (oe(l3, 1, 2, n, o2), re(l3[0])) return "Unknown";
      if (ne(l3[0])) return "Unknown";
      if (B(l3[0])) {
        if (await l3[0].load(), 1 === l3.length || null === l3[1]) return l3[0].datesInUnknownTimezone ? ce("unknown") : ce(l3[0].dateFieldsTimeZone);
        if (!(l3[1] instanceof C) || false === l3[1].hasField("type")) throw new a(n, r2.InvalidParameter, o2);
        const e5 = l3[1].field("type");
        if (false === e(e5)) throw new a(n, r2.InvalidParameter, o2);
        switch (ye(e5).toLowerCase()) {
          case "preferredtimezone":
            return ce(l3[0].preferredTimeZone);
          case "editfieldsinfo":
            return ce(((_a = l3[0].editFieldsInfo) == null ? void 0 : _a.timeZone) ?? null);
          case "timeinfo":
            return ce(((_b = l3[0].timeInfo) == null ? void 0 : _b.timeZone) ?? null);
          case "field":
            if (l3[1].hasField("fieldname") && e(l3[1].field("fieldname"))) return ce(l3[0].fieldTimeZone(ye(l3[1].field("fieldname"))));
        }
        throw new a(n, r2.InvalidParameter, o2);
      }
      const f = Ne(l3[0], Be(n));
      if (null === f) return null;
      const d = f.timeZone;
      return "system" === d ? m.systemTimeZoneCanonicalName : "utc" === d.toLowerCase() ? "UTC" : "unknown" === d.toLowerCase() ? "Unknown" : d;
    });
  }, e3.functions.sqltimestamp = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      oe(o2, 1, 3, t3, n);
      const s2 = o2[0];
      if (te(s2)) {
        if (1 === o2.length) return s2.toSQLWithKeyword();
        if (2 === o2.length) return s2.changeTimeZone(ye(o2[1])).toSQLWithKeyword();
        throw new a(t3, r2.InvalidParameter, n);
      }
      if (ne(s2)) return s2.toSQLWithKeyword();
      if (B(s2)) {
        if (3 !== o2.length) throw new a(t3, r2.InvalidParameter, n);
        await s2.load();
        const e5 = ye(o2[1]);
        if (ne(o2[2])) return o2[2].toSQLWithKeyword();
        if (false === te(o2[2])) throw new a(t3, r2.InvalidParameter, n);
        const i2 = s2.fieldTimeZone(e5);
        return null == i2 ? o2[2].toSQLWithKeyword() : o2[2].changeTimeZone(i2).toSQLWithKeyword();
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "sqltimestamp", min: 2, max: 4 }), e3.functions.featuresetbyid = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, (e4, i, o2) => {
      if (oe(o2, 2, 4, t3, n), Q(o2[0])) {
        const e5 = ye(o2[1]);
        let i2 = q(o2[2], null);
        const s2 = Ze(q(o2[3], true));
        if (null === i2 && (i2 = ["*"]), false === o(i2)) throw new a(t3, r2.InvalidParameter, n);
        return o2[0].featureSetById(e5, s2, i2);
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "featuresetbyid", min: 2, max: 4 }), e3.functions.getfeatureset = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      if (oe(o2, 1, 2, t3, n), H(o2[0])) {
        let e5 = q(o2[1], "datasource");
        return null === e5 && (e5 = "datasource"), e5 = ye(e5).toLowerCase(), R2(o2[0].fullSchema(), e5, t3.lrucache, t3.interceptor, t3.spatialReference ?? null);
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "getfeatureset", min: 1, max: 2 }), e3.functions.featuresetbyportalitem = function(t3, i) {
    return e3.standardFunctionAsync(t3, i, (e4, o2, s2) => {
      var _a, _b;
      if (oe(s2, 2, 5, t3, i), null === s2[0]) throw new a(t3, r2.PortalRequired, i);
      if (s2[0] instanceof t2) {
        const e5 = ye(s2[1]), n = ye(s2[2]);
        let o3 = q(s2[3], null);
        const f2 = Ze(q(s2[4], true));
        if (null === o3 && (o3 = ["*"]), false === o(o3)) throw new a(t3, r2.InvalidParameter, i);
        let d2;
        return d2 = ((_a = t3.services) == null ? void 0 : _a.portal) ? t3.services.portal : C2.getDefault(), d2 = l2(s2[0], d2), q2(e5, n, t3.spatialReference ?? null, o3, f2, d2, t3.lrucache, t3.interceptor);
      }
      if (false === e(s2[0])) throw new a(t3, r2.PortalRequired, i);
      const f = ye(s2[0]), d = ye(s2[1]);
      let u2 = q(s2[2], null);
      const c2 = Ze(q(s2[3], true));
      if (null === u2 && (u2 = ["*"]), false === o(u2)) throw new a(t3, r2.InvalidParameter, i);
      return q2(f, d, t3.spatialReference ?? null, u2, c2, ((_b = t3.services) == null ? void 0 : _b.portal) ?? C2.getDefault(), t3.lrucache, t3.interceptor);
    });
  }, e3.signatures.push({ name: "featuresetbyportalitem", min: 2, max: 5 }), e3.functions.featuresetbyname = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, (e4, i, o2) => {
      if (oe(o2, 2, 4, t3, n), Q(o2[0])) {
        const e5 = ye(o2[1]);
        let i2 = q(o2[2], null);
        const s2 = Ze(q(o2[3], true));
        if (null === i2 && (i2 = ["*"]), false === o(i2)) throw new a(t3, r2.InvalidParameter, n);
        return o2[0].featureSetByName(e5, s2, i2);
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "featuresetbyname", min: 2, max: 4 }), e3.functions.featureset = function(t3, n) {
    return e3.standardFunction(t3, n, (e4, o2, s2) => {
      oe(s2, 1, 1, t3, n);
      const l3 = { layerDefinition: { geometryType: "", objectIdField: "", globalIdField: "", typeIdField: "", hasM: false, hasZ: false, fields: [] }, featureSet: { geometryType: "", features: [] } };
      if (e(s2[0])) {
        const e5 = JSON.parse(s2[0]);
        void 0 !== e5.layerDefinition ? (l3.layerDefinition = e5.layerDefinition, l3.featureSet = e5.featureSet, e5.layerDefinition.spatialReference && (l3.layerDefinition.spatialReference = e5.layerDefinition.spatialReference)) : (l3.featureSet.features = e5.features, l3.featureSet.geometryType = e5.geometryType, l3.layerDefinition.geometryType = l3.featureSet.geometryType, l3.layerDefinition.objectIdField = e5.objectIdFieldName ?? "", l3.layerDefinition.typeIdField = e5.typeIdFieldName, l3.layerDefinition.globalIdField = e5.globalIdFieldName, l3.layerDefinition.fields = e5.fields, e5.spatialReference && (l3.layerDefinition.spatialReference = e5.spatialReference));
      } else {
        if (!(s2[0] instanceof C)) throw new a(t3, r2.InvalidParameter, n);
        {
          const e5 = JSON.parse(s2[0].castToText(true)), i = oe2(e5, "layerdefinition");
          if (null !== i) {
            l3.layerDefinition.geometryType = oe2(i, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.globalIdField = oe2(i, "globalidfield", ""), l3.layerDefinition.objectIdField = oe2(i, "objectidfield", ""), l3.layerDefinition.typeIdField = oe2(i, "typeidfield", ""), l3.layerDefinition.hasZ = true === oe2(i, "hasz", false), l3.layerDefinition.hasM = true === oe2(i, "hasm", false);
            const t4 = oe2(i, "spatialreference");
            t4 && (l3.layerDefinition.spatialReference = le(t4));
            const n2 = [];
            for (const e6 of oe2(i, "fields", [])) {
              const t5 = { name: oe2(e6, "name", ""), alias: oe2(e6, "alias", ""), type: oe2(e6, "type", ""), nullable: oe2(e6, "nullable", true), editable: oe2(e6, "editable", true), length: oe2(e6, "length", null), domain: se(oe2(e6, "domain")) };
              n2.push(t5);
            }
            l3.layerDefinition.fields = n2;
            const a5 = oe2(e5, "featureset");
            if (a5) {
              const e6 = {};
              for (const t5 of n2) e6[t5.name.toLowerCase()] = t5.name;
              for (const t5 of oe2(a5, "features", [])) {
                const n3 = {}, i2 = oe2(t5, "attributes", {});
                for (const t6 in i2) n3[e6[t6.toLowerCase()]] = i2[t6];
                l3.featureSet.features.push({ attributes: n3, geometry: fe(oe2(t5, "geometry")) });
              }
            }
          } else {
            l3.layerDefinition.hasZ = true === oe2(e5, "hasz", false), l3.layerDefinition.hasM = true === oe2(e5, "hasm", false), l3.layerDefinition.geometryType = oe2(e5, "geometrytype", ""), l3.featureSet.geometryType = l3.layerDefinition.geometryType, l3.layerDefinition.objectIdField = oe2(e5, "objectidfieldname", ""), l3.layerDefinition.typeIdField = oe2(e5, "typeidfieldname", "");
            const i2 = oe2(e5, "spatialreference");
            i2 && (l3.layerDefinition.spatialReference = le(i2));
            const o3 = [], s3 = oe2(e5, "fields", null);
            if (!o(s3)) throw new a(t3, r2.InvalidParameter, n);
            for (const e6 of s3) {
              const t4 = { name: oe2(e6, "name", ""), alias: oe2(e6, "alias", ""), type: oe2(e6, "type", ""), nullable: oe2(e6, "nullable", true), editable: oe2(e6, "editable", true), length: oe2(e6, "length", null), domain: se(oe2(e6, "domain")) };
              o3.push(t4);
            }
            l3.layerDefinition.fields = o3;
            const f = {};
            for (const e6 of o3) f[e6.name.toLowerCase()] = e6.name;
            let d = oe2(e5, "features", null);
            if (o(d)) for (const e6 of d) {
              const t4 = {}, n2 = oe2(e6, "attributes", {});
              for (const e7 in n2) t4[f[e7.toLowerCase()]] = n2[e7];
              l3.featureSet.features.push({ attributes: t4, geometry: fe(oe2(e6, "geometry", null)) });
            }
            else d = null, l3.featureSet.features = d;
          }
        }
      }
      if (false === ue(l3)) throw new a(t3, r2.InvalidParameter, n);
      return l3.layerDefinition.geometryType || (l3.layerDefinition.geometryType = "esriGeometryNull"), p.create(l3, t3.spatialReference);
    });
  }, e3.signatures.push({ name: "featureset", min: 1, max: 1 }), e3.functions.filter = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (i, o2, s2) => {
      if (oe(s2, 2, 2, t3, n), o(s2[0]) || ee(s2[0])) {
        const e4 = [];
        let i2, o3 = s2[0];
        if (o3 instanceof t && (o3 = o3.toArray()), !G(s2[1])) throw new a(t3, r2.InvalidParameter, n);
        i2 = s2[1].createFunction(t3);
        for (const t4 of o3) {
          const n2 = i2(t4);
          S(n2) ? true === await n2 && e4.push(t4) : true === n2 && e4.push(t4);
        }
        return e4;
      }
      if (B(s2[0])) {
        const n2 = await s2[0].load(), i2 = D.create(s2[1], { fieldsIndex: n2.getFieldsIndex(), timeZone: n2.dateFieldsTimeZoneDefaultUTC }), a5 = i2.getVariables();
        if (a5.length > 0) {
          const n3 = {};
          for (const i3 of a5) n3[i3] = e3.evaluateIdentifier(t3, { name: i3 });
          i2.parameters = n3;
        }
        return new c({ parentfeatureset: s2[0], whereclause: i2 });
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "filter", min: 2, max: 2 }), e3.functions.orderby = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      if (oe(o2, 2, 2, t3, n), B(o2[0])) {
        const e5 = new e2(o2[1]);
        return new a2({ parentfeatureset: o2[0], orderbyclause: e5 });
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "orderby", min: 2, max: 2 }), e3.functions.top = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      if (oe(o2, 2, 2, t3, n), B(o2[0])) return new a3({ parentfeatureset: o2[0], topnum: o2[1] });
      if (o(o2[0])) return be(o2[1]) >= o2[0].length ? o2[0].slice() : o2[0].slice(0, be(o2[1]));
      if (ee(o2[0])) return be(o2[1]) >= o2[0].length() ? o2[0].slice() : o2[0].slice(0, be(o2[1]));
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "top", min: 2, max: 2 }), e3.functions.first = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, a5) => {
      if (oe(a5, 1, 1, t3, n), B(a5[0])) {
        const n2 = await a5[0].first(e4.abortSignal);
        if (null !== n2) {
          const e5 = D2.createFromGraphicLikeObject(n2.geometry, n2.attributes, a5[0], t3.timeZone);
          return e5._underlyingGraphic = n2, e5;
        }
        return n2;
      }
      return o(a5[0]) ? 0 === a5[0].length ? null : a5[0][0] : ee(a5[0]) ? 0 === a5[0].length() ? null : a5[0].get(0) : null;
    });
  }, e3.signatures.push({ name: "first", min: 1, max: 1 }), e3.functions.attachments = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, o2, s2) => {
      oe(s2, 1, 2, t3, n);
      const l3 = { minsize: -1, maxsize: -1, types: null, returnMetadata: false };
      if (s2.length > 1) {
        if (s2[1] instanceof C) {
          if (s2[1].hasField("minsize") && (l3.minsize = be(s2[1].field("minsize"))), s2[1].hasField("metadata") && (l3.returnMetadata = Ze(s2[1].field("metadata"))), s2[1].hasField("maxsize") && (l3.maxsize = be(s2[1].field("maxsize"))), s2[1].hasField("types")) {
            const e5 = _e(s2[1].field("types"), false);
            e5.length > 0 && (l3.types = e5);
          }
        } else if (null !== s2[1]) throw new a(t3, r2.InvalidParameter, n);
      }
      if (H(s2[0])) {
        const e5 = s2[0]._layer;
        let n2;
        if (B(e5)) n2 = e5;
        else {
          if (null == e5 || !x(e5)) return [];
          n2 = N(e5, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor);
        }
        return await n2.load(), n2.queryAttachments(s2[0].field(n2.objectIdField), l3.minsize, l3.maxsize, l3.types, l3.returnMetadata);
      }
      if (null === s2[0]) return [];
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "attachments", min: 1, max: 2 }), e3.functions.featuresetbyrelationshipname = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      oe(o2, 2, 4, t3, n);
      const s2 = o2[0], l3 = ye(o2[1]);
      let c2 = q(o2[2], null);
      const m2 = Ze(q(o2[3], true));
      if (null === c2 && (c2 = ["*"]), false === o(c2)) throw new a(t3, r2.InvalidParameter, n);
      if (null === o2[0]) return null;
      if (!H(o2[0])) throw new a(t3, r2.InvalidParameter, n);
      const y2 = s2._layer;
      let w;
      if (B(y2)) w = y2;
      else {
        if (null == y2 || !x(y2)) return null;
        w = N(y2, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor);
      }
      w = await w.load();
      const g = w.relationshipMetaData().filter((e5) => e5.name === l3);
      if (0 === g.length) return null;
      if (void 0 !== g[0].relationshipTableId && null !== g[0].relationshipTableId && g[0].relationshipTableId > -1) return j(w, g[0], s2.field(w.objectIdField), w.spatialReference, c2, m2, t3.lrucache, t3.interceptor);
      let F2 = w.serviceUrl();
      if (!F2) return null;
      F2 = "/" === F2.charAt(F2.length - 1) ? F2 + g[0].relatedTableId.toString() : F2 + "/" + g[0].relatedTableId.toString();
      const b3 = await F(F2, w.spatialReference, c2, m2, t3.lrucache, t3.interceptor);
      await b3.load();
      let T = b3.relationshipMetaData();
      if (T = T.filter((e5) => e5.id === g[0].id), false === s2.hasField(g[0].keyField) || null === s2.field(g[0].keyField)) {
        const e5 = await w.getFeatureByObjectId(s2.field(w.objectIdField), [g[0].keyField]);
        if (e5) {
          const t4 = D.create(T[0].keyField + "= @id", { fieldsIndex: b3.getFieldsIndex(), timeZone: b3.dateFieldsTimeZoneDefaultUTC });
          return t4.parameters = { id: e5.attributes[g[0].keyField] }, b3.filter(t4);
        }
        return new u({ parentfeatureset: b3 });
      }
      const N2 = D.create(T[0].keyField + "= @id", { fieldsIndex: b3.getFieldsIndex(), timeZone: b3.dateFieldsTimeZoneDefaultUTC });
      return N2.parameters = { id: s2.field(g[0].keyField) }, b3.filter(N2);
    });
  }, e3.signatures.push({ name: "featuresetbyrelationshipname", min: 2, max: 4 }), e3.functions.featuresetbyassociation = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      oe(o2, 2, 3, t3, n);
      const s2 = o2[0], l3 = ye(q(o2[1], "")).toLowerCase(), d = e(o2[2]) ? ye(o2[2]) : null;
      if (null === o2[0]) return null;
      if (!H(o2[0])) throw new a(t3, r2.InvalidParameter, n);
      let u2 = s2._layer;
      if (u2 instanceof Ye && (u2 = N(u2, t3.spatialReference, ["*"], true, t3.lrucache, t3.interceptor)), null === u2) return null;
      if (false === B(u2)) return null;
      await u2.load();
      const m2 = u2.serviceUrl(), y2 = await E(m2, t3.spatialReference, true);
      if (y2.unVersion >= 8) return await me(u2, s2, l3, d, y2, t3, n);
      const w = y2.associations;
      let g = null, F2 = null, b3 = false;
      if (null !== d && "" !== d && void 0 !== d) {
        for (const e5 of y2.terminals) e5.terminalName === d && (F2 = e5.terminalId);
        null === F2 && (b3 = true);
      }
      const T = w.getFieldsIndex(), x2 = T.get("TOGLOBALID").name, N2 = T.get("FROMGLOBALID").name, A = T.get("TOTERMINALID").name, v = T.get("FROMTERMINALID").name, S2 = T.get("FROMNETWORKSOURCEID").name, j2 = T.get("TONETWORKSOURCEID").name, U = T.get("ASSOCIATIONTYPE").name, M = T.get("ISCONTENTVISIBLE").name, R3 = T.get("OBJECTID").name;
      for (const t4 of u2.fields) if ("global-id" === t4.type) {
        g = s2.field(t4.name);
        break;
      }
      let O2 = null, z = new L(new y({ name: "percentalong", alias: "percentalong", type: "double" }), D.create("0", { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC })), W = new L(new y({ name: "side", alias: "side", type: "string" }), D.create("''", { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC }));
      const H2 = "globalid", V = "globalId", _ = {};
      for (const t4 in y2.lkp) _[t4] = y2.lkp[t4].sourceId;
      const K = new B2(new y({ name: "classname", alias: "classname", type: "string" }), null, _);
      let J = "";
      switch (l3) {
        case "midspan": {
          J = `((${x2}='${g}') OR ( ${N2}='${g}')) AND (${U} IN (5))`, K.codefield = D.create(`CASE WHEN (${x2}='${g}') THEN ${S2} ELSE ${j2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC });
          const e5 = s(R.findField(w.fields, N2));
          e5.name = H2, e5.alias = H2, O2 = new L(e5, D.create(`CASE WHEN (${N2}='${g}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC })), z = y2.unVersion >= 4 ? new k(R.findField(w.fields, T.get("PERCENTALONG").name)) : new L(new y({ name: "percentalong", alias: "percentalong", type: "double" }), D.create("0", { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "junctionedge": {
          J = `((${x2}='${g}') OR ( ${N2}='${g}')) AND (${U} IN (4,6))`, K.codefield = D.create(`CASE WHEN (${x2}='${g}') THEN ${S2} ELSE ${j2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC });
          const e5 = s(R.findField(w.fields, N2));
          e5.name = H2, e5.alias = H2, O2 = new L(e5, D.create(`CASE WHEN (${N2}='${g}') THEN ${x2} ELSE ${N2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC })), W = new L(new y({ name: "side", alias: "side", type: "string" }), D.create(`CASE WHEN (${U}=4) THEN 'from' ELSE 'to' END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "connected": {
          let e5 = `${x2}='@T'`, t4 = `${N2}='@T'`;
          null !== F2 && (e5 += ` AND ${A}=@A`, t4 += ` AND ${v}=@A`), J = "((" + e5 + ") OR (" + t4 + "))", J = P(J, "@T", g ?? ""), e5 = P(e5, "@T", g ?? ""), null !== F2 && (e5 = P(e5, "@A", F2.toString()), J = P(J, "@A", F2.toString())), K.codefield = D.create("CASE WHEN " + e5 + ` THEN ${S2} ELSE ${j2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC });
          const n2 = s(R.findField(w.fields, N2));
          n2.name = H2, n2.alias = H2, O2 = new L(n2, D.create("CASE WHEN " + e5 + ` THEN ${N2} ELSE ${x2} END`, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC }));
          break;
        }
        case "container":
          J = `${x2}='${g}' AND ${U} = 2`, null !== F2 && (J += ` AND ${A} = ` + F2.toString()), K.codefield = S2, J = "( " + J + " )", O2 = new b2(R.findField(w.fields, N2), H2, H2);
          break;
        case "content":
          J = `(${N2}='${g}' AND ${U} = 2)`, null !== F2 && (J += ` AND ${v} = ` + F2.toString()), K.codefield = j2, J = "( " + J + " )", O2 = new b2(R.findField(w.fields, x2), H2, H2);
          break;
        case "structure":
          J = `(${x2}='${g}' AND ${U} = 3)`, null !== F2 && (J += ` AND ${A} = ` + F2.toString()), K.codefield = S2, J = "( " + J + " )", O2 = new b2(R.findField(w.fields, N2), H2, V);
          break;
        case "attached":
          J = `(${N2}='${g}' AND ${U} = 3)`, null !== F2 && (J += ` AND ${v} = ` + F2.toString()), K.codefield = j2, J = "( " + J + " )", O2 = new b2(R.findField(w.fields, x2), H2, V);
          break;
        default:
          throw new a(t3, r2.InvalidParameter, n);
      }
      b3 && (J = "1 <> 1");
      return new R({ parentfeatureset: w, adaptedFields: [new k(R.findField(w.fields, R3)), new k(R.findField(w.fields, M)), O2, W, K, z], extraFilter: J ? D.create(J, { fieldsIndex: w.getFieldsIndex(), timeZone: w.dateFieldsTimeZoneDefaultUTC }) : null });
    });
  }, e3.signatures.push({ name: "featuresetbyassociation", min: 2, max: 6 }), e3.functions.groupby = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (o2, s2, l3) => {
      if (oe(l3, 3, 3, t3, n), !B(l3[0])) throw new a(t3, r2.InvalidParameter, n);
      const f = await l3[0].load(), d = [], u2 = [];
      let c2 = false, m2 = [];
      if (e(l3[1])) m2.push(l3[1]);
      else if (l3[1] instanceof C) m2.push(l3[1]);
      else if (o(l3[1])) m2 = l3[1];
      else {
        if (!ee(l3[1])) throw new a(t3, r2.InvalidParameter, n);
        m2 = l3[1].toArray();
      }
      for (const e4 of m2) if (e(e4)) {
        const t4 = D.create(ye(e4), { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }), n2 = true === O(t4) ? ye(e4) : "%%%%FIELDNAME";
        d.push({ name: n2, expression: t4 }), "%%%%FIELDNAME" === n2 && (c2 = true);
      } else {
        if (!(e4 instanceof C)) throw new a(t3, r2.InvalidParameter, n);
        {
          const i = e4.hasField("name") ? e4.field("name") : "%%%%FIELDNAME", o3 = e4.hasField("expression") ? e4.field("expression") : "";
          if ("%%%%FIELDNAME" === i && (c2 = true), !i) throw new a(t3, r2.InvalidParameter, n);
          d.push({ name: i, expression: D.create(o3 || i, { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }) });
        }
      }
      if (m2 = [], e(l3[2])) m2.push(l3[2]);
      else if (o(l3[2])) m2 = l3[2];
      else if (ee(l3[2])) m2 = l3[2].toArray();
      else {
        if (!(l3[2] instanceof C)) throw new a(t3, r2.InvalidParameter, n);
        m2.push(l3[2]);
      }
      for (const e4 of m2) {
        if (!(e4 instanceof C)) throw new a(t3, r2.InvalidParameter, n);
        {
          const i = e4.hasField("name") ? e4.field("name") : "", o3 = e4.hasField("statistic") ? e4.field("statistic") : "", s3 = e4.hasField("expression") ? e4.field("expression") : "";
          if (!i || !o3 || !s3) throw new a(t3, r2.InvalidParameter, n);
          u2.push({ name: i, statistic: o3.toLowerCase(), expression: D.create(s3, { fieldsIndex: f.getFieldsIndex(), timeZone: f.dateFieldsTimeZoneDefaultUTC }) });
        }
      }
      if (c2) {
        const e4 = {};
        for (const n2 of f.fields) e4[n2.name.toLowerCase()] = 1;
        for (const n2 of d) "%%%%FIELDNAME" !== n2.name && (e4[n2.name.toLowerCase()] = 1);
        for (const n2 of u2) "%%%%FIELDNAME" !== n2.name && (e4[n2.name.toLowerCase()] = 1);
        let t4 = 0;
        for (const n2 of d) if ("%%%%FIELDNAME" === n2.name) {
          for (; 1 === e4["field_" + t4.toString()]; ) t4++;
          e4["field_" + t4.toString()] = 1, n2.name = "FIELD_" + t4.toString();
        }
      }
      for (const n2 of d) re2(n2.expression, e3, t3);
      for (const n2 of u2) re2(n2.expression, e3, t3);
      return l3[0].groupby(d, u2);
    });
  }, e3.signatures.push({ name: "groupby", min: 3, max: 3 }), e3.functions.distinct = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (o2, s2, l3) => {
      if (B(l3[0])) {
        oe(l3, 2, 2, t3, n);
        const o3 = await l3[0].load(), s3 = [];
        let f = [];
        if (e(l3[1])) f.push(l3[1]);
        else if (l3[1] instanceof C) f.push(l3[1]);
        else if (o(l3[1])) f = l3[1];
        else {
          if (!ee(l3[1])) throw new a(t3, r2.InvalidParameter, n);
          f = l3[1].toArray();
        }
        let d = false;
        for (const e4 of f) if (e(e4)) {
          const t4 = D.create(ye(e4), { fieldsIndex: o3.getFieldsIndex(), timeZone: o3.dateFieldsTimeZoneDefaultUTC }), n2 = true === O(t4) ? ye(e4) : "%%%%FIELDNAME";
          s3.push({ name: n2, expression: t4 }), "%%%%FIELDNAME" === n2 && (d = true);
        } else {
          if (!(e4 instanceof C)) throw new a(t3, r2.InvalidParameter, n);
          {
            const i = e4.hasField("name") ? e4.field("name") : "%%%%FIELDNAME", l4 = e4.hasField("expression") ? e4.field("expression") : "";
            if ("%%%%FIELDNAME" === i && (d = true), !i) throw new a(t3, r2.InvalidParameter, n);
            s3.push({ name: i, expression: D.create(l4 || i, { fieldsIndex: o3.getFieldsIndex(), timeZone: o3.dateFieldsTimeZoneDefaultUTC }) });
          }
        }
        if (d) {
          const e4 = {};
          for (const n2 of o3.fields) e4[n2.name.toLowerCase()] = 1;
          for (const n2 of s3) "%%%%FIELDNAME" !== n2.name && (e4[n2.name.toLowerCase()] = 1);
          let t4 = 0;
          for (const n2 of s3) if ("%%%%FIELDNAME" === n2.name) {
            for (; 1 === e4["field_" + t4.toString()]; ) t4++;
            e4["field_" + t4.toString()] = 1, n2.name = "FIELD_" + t4.toString();
          }
        }
        for (const n2 of s3) re2(n2.expression, e3, t3);
        return l3[0].groupby(s3, []);
      }
      return ae(l3);
    });
  }, e3.functions.getfeaturesetinfo = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, a5, r3) => {
      if (oe(r3, 1, 1, t3, n), !B(r3[0])) return null;
      const o2 = await r3[0].getFeatureSetInfo();
      return o2 ? C.convertObjectToArcadeDictionary({ layerId: o2.layerId, layerName: o2.layerName, itemId: o2.itemId, serviceLayerUrl: o2.serviceLayerUrl, webMapLayerId: o2.webMapLayerId ?? null, webMapLayerTitle: o2.webMapLayerTitle ?? null, className: null, objectClassId: null }, Be(t3), false, false) : null;
    });
  }, e3.signatures.push({ name: "getfeaturesetinfo", min: 1, max: 1 }), e3.functions.filterbysubtypecode = function(t3, n) {
    return e3.standardFunctionAsync(t3, n, async (e4, i, o2) => {
      if (oe(o2, 2, 2, t3, n), B(o2[0])) {
        const e5 = await o2[0].load(), i2 = o2[1];
        if (!r(i2)) throw new a(t3, r2.InvalidParameter, n);
        if (e5.subtypeField) {
          const t4 = D.create(`${e5.subtypeField}= ${o2[1]}`, { fieldsIndex: e5.getFieldsIndex(), timeZone: e5.dateFieldsTimeZoneDefaultUTC });
          return new c({ parentfeatureset: o2[0], whereclause: t4 });
        }
        if (null === e5.typeIdField || "" === e5.typeIdField) throw new a(t3, r2.FeatureSetDoesNotHaveSubtypes, n);
        const s2 = D.create(`${e5.typeIdField}= ${o2[1]}`, { fieldsIndex: e5.getFieldsIndex(), timeZone: e5.dateFieldsTimeZoneDefaultUTC });
        return new c({ parentfeatureset: o2[0], whereclause: s2 });
      }
      throw new a(t3, r2.InvalidParameter, n);
    });
  }, e3.signatures.push({ name: "filterbysubtypecode", min: 2, max: 2 }));
}
export {
  pe as registerFunctions
};
//# sourceMappingURL=featuresetbase-SWYECWBL.js.map
